#include <CoreFoundation/CoreFoundation.h>#include <IOKit/IOKitLib.h>#include <IOKit/scsi-commands/SCSITaskLib.h>#include <Kernel/mach/mach_port.h>#define DEMO_VERSION#include <stdlib.h>#include <unistd.h>#include <time.h>#define ReadFromSCSI		0#define WriteToSCSI			1#define SkipDataBlocks		0#define SkipTapeMarks		1          struct scsi_1{                  unsigned char    dev_type;                  unsigned char    rmb:1;                  unsigned char    dtq:7;                  unsigned char    iso:2;                  unsigned char    ecma:3;                  unsigned char    ansi:3;                  unsigned char    resv:4;                  unsigned char    rdf:4;                  unsigned char    added_len;                  unsigned char    dev_class[3];                  char             vendor_id[8];                  char             product_id[16];                  char             rev_num[4];                  unsigned char    vendor_spec[20];                  unsigned char    resv4[40];                  unsigned char    vendor_parm_bytes[32];          };          /* SCSI-2 inquiry structure */          struct scsi_2 {                  unsigned char    periph_qualifier:3;                  unsigned char    dev_type:5;                  unsigned char    rmb:1;                  unsigned char    dtq:7;                  unsigned char    iso:2;                  unsigned char    ecma:3;                  unsigned char    ansi:3;                  unsigned char    aenc:1;                  unsigned char    trmiop:1;                  unsigned char    resv1:2;                  unsigned char    rdf:4;                  unsigned char    added_len;                  unsigned char    resv2[2];                  unsigned char    reladr:1;                  unsigned char    wbus32:1;                  unsigned char    wbus16:1;                  unsigned char    sync:1;                  unsigned char    linked:1;                  unsigned char    resv3:1;                  unsigned char    cmdque:1;                  unsigned char    sftre:1;                  char             vendor_id[8];                  char             product_id[16];                  char             rev_num[4];                  unsigned char    vendor_spec[20];                  unsigned char    resv4[40];                  unsigned char    vendor_parm_bytes[32];          };          /* union for SIOC_INQUIRY ioctl */          union scsi_data {                  struct scsi_1 scsi1;    /* SCSI-1 inquiry */                  struct scsi_2 scsi2;    /* SCSI-2 inquiry */          };struct scsiDataStruct{   char vendorIDFound[64],productIDFound[64],firmwareRevLevelFound[64];    UInt32 MaxBlock;    UInt32 MinBlock;        UInt32 Density;    UInt32 BufferMode;    UInt32 WriteProtect;    UInt32 BlockSize;        int FixedBlock;        int BlockCount;    int PrintLevel;    int BlockSizeRead;        int skipMarks;    int skipMarkType;    int writeMarks;        int AskNextTape;        };struct Sensedata{	SCSITaskStatus taskStatus;    UInt64 transferCount;    SCSI_Sense_Data senseData;};void ModeWrite(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int getString(unsigned char *s,long n,FILE *in);int readTapeBlocks(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData);int writeTapeBlocks(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData);int doDevice(io_service_t service,struct scsiDataStruct *scsiData,             int (*pUpdateWrite)(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData));void ReadPostion(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int AnalyzeDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int RewindDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int SkipDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int ReadDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int WriteDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int SetBlockDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int skipTape(SCSITaskDeviceInterface **interface,int FileMarksToSkip,int type);void Inquiry(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);void rewindTape(SCSITaskDeviceInterface **interface);void PrintSenseString ( SCSI_Sense_Data * sense );int putString(unsigned char *s,long n,FILE *in);int eatSpaces(char *name);void ModeSense6(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);int ReadBlockLimits(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData);void TestUnitReady(SCSITaskDeviceInterface **interface);int writeFileMarks(SCSITaskDeviceInterface **interface,int FileMarksToWrite);int AnalyzeDevices(io_service_t service,struct scsiDataStruct *scsiData);int readwriteSCSI(SCSICommandDescriptorBlock cdb,SCSITaskDeviceInterface **interface,unsigned char *buff,                  unsigned long bufflength,int direction,struct Sensedata *senseDataRet);int readwriteSCSI10(SCSICommandDescriptorBlock cdb,SCSITaskDeviceInterface **interface,unsigned char *buff,                  unsigned long bufflength,int direction,struct Sensedata *senseDataRet);/*char *vendorIDSearch="SONY";char *productIDSearch="SDT-9000";char *firmwareRevLevelSearch="0400";*//*char *vendorIDSearch="HP";char *productIDSearch="C1533A";char *firmwareRevLevelSearch="9406";*//*char *vendorIDSearch="EXABYTE";char *productIDSearch="EXB-8200";char *firmwareRevLevelSearch="2618";*/static FILE *ttyin;static int debug=0;int process(int argc, const char *argv[],CFMutableArrayRef	deviceArray);int readTapeBlocksOLD(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData);int readTapeBlocksOLD3(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData);int readTapeBlocksOLD4(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData);int readTapeBlocksOld8(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData);int isTapeMark(SCSI_Sense_Data *senseData);int isEOM(SCSI_Sense_Data *senseData);int main (int argc, const char *argv[]){	CFMutableArrayRef	deviceArray			= CFArrayCreateMutable(kCFAllocatorDefault, 0, nil) ;    io_iterator_t scsiObjectIterator = NULL;    IOReturn ioReturnValue = kIOReturnSuccess;    mach_port_t masterPort;    CFMutableDictionaryRef matchingDict;    CFMutableDictionaryRef subDict;    kern_return_t kr;    Boolean noMatchingDevices = true;#ifdef DEMO_VERSION	char *home;	char home2[2048];	FILE *out;	time_t now,then;		home=getenv("HOME");	if(home){	     strncpy(home2,home,2040);		 strncat(home2,"/Library/Preferences/com.utmac.utmac.Preferences",2048);		 out=fopen(home2,"r");		 if(!out){		     out=fopen(home2,"w");			 if(!out){				fprintf(stderr,"tuOSX: Preference File Error 1\n");				return -1;			 }			 now=time(NULL);			 if(now == ((time_t) -1)){				fprintf(stderr,"tuOSX: Preference File Error 2\n");				return -1;			 }			if( putString((unsigned char *)&now,(long)sizeof(now),out)){				fprintf(stderr,"tuOSX: Preference File Error 3\n");				return -1;			}		 }else{			if( getString((unsigned char *)&then,(long)sizeof(then),out) <= 0){				fprintf(stderr,"tuOSX: Preference File Error 4\n");				return -1;			}			 now=time(NULL);			 if(now == ((time_t) -1)){				fprintf(stderr,"tuOSX: Preference File Error 5\n");				return -1;			 }						if((then+3600*24*7) < now){				fprintf(stderr,"tuOSX: Demo Version Time Expired\n");				return -1;			}		 }		 if(out)fclose(out);	}else{		fprintf(stderr,"tuOSX: Preference File Error\n 6");		return -1;	}#endif	ttyin=fopen("/dev/tty","r");	    kr = IOMasterPort(MACH_PORT_NULL, &masterPort);    if (kr || !masterPort)    {        fprintf(stderr,"ERR: Couldn't create a master IOKit Port(%08x)\n", kr);        return -1;    }        matchingDict = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL,NULL );         subDict = CFDictionaryCreateMutable ( kCFAllocatorDefault, 0, NULL,NULL );            CFDictionarySetValue ( subDict,                            CFSTR ( kIOPropertySCSITaskDeviceCategory ),                            CFSTR ( kIOPropertySCSITaskUserClientDevice ) );                                                                CFDictionarySetValue ( matchingDict, CFSTR ( kIOPropertyMatchKey ),subDict );            ioReturnValue = IOServiceGetMatchingServices(masterPort,matchingDict, &scsiObjectIterator);      noMatchingDevices = ((ioReturnValue != kIOReturnSuccess) | (scsiObjectIterator == NULL));        if (noMatchingDevices){        fprintf(stderr,"No matching SCSI devices found.\n");        goto ErrorOut;    }	{		io_object_t		newDevice ;				while( 0 != (newDevice = IOIteratorNext(scsiObjectIterator)) )		{			CFArrayAppendValue(deviceArray, (void*) newDevice) ;		}	}	process(argc,argv,deviceArray);	ErrorOut:    mach_port_deallocate(mach_task_self(), masterPort);        masterPort = 0;        IOObjectRelease(scsiObjectIterator);    	CFRelease(deviceArray) ;		    exit(0);        return 0;}int process(int argc, const char *argv[],CFMutableArrayRef	deviceArray){	struct scsiDataStruct scsiData;		io_object_t currentDevice ;	int device,deviceCount;	int ret,skipMarks;    int FixedBlock;    int AskNextTape;    int BlockCount;    int BlockSizeRead;    int writeMarks;    int skipMarkType;	int index;	int n;		if(!deviceArray)return 1;		ret = 1;		FixedBlock=1;		BlockCount=20;	BlockSizeRead=1024;		device = -1;		writeMarks = 1;		AskNextTape = TRUE;		deviceCount=CFArrayGetCount(deviceArray);		if(deviceCount == 1){	   device = 0;	}else{	   device = -1;	}		if(argc <= 1){	    n=1;	    goto Analyze;	}		for(n=1;n<argc;++n){			if(!strcmp("status",argv[n])){	Analyze:				for(index = 0; index < deviceCount; index++)			{								if(index == device || device == -1){									currentDevice = (io_object_t) CFArrayGetValueAtIndex(deviceArray, index);						    			memset ( &scsiData, 0, sizeof ( struct scsiDataStruct ) );	    				    			scsiData.PrintLevel=1;	    				    			fprintf(stderr,"Tape = %d\n",index);					doDevice((io_service_t)currentDevice,&scsiData,AnalyzeDevice);				    			    }							}		}else if(!strcmp("-t",argv[n])){		    ++n;			device = atoi(argv[n]);			if(device < 0 || device >= deviceCount){    		    fprintf(stderr,"tape number (%d) is out of range \n",device);		   				device = -1;			}		}else if(!strcmp("rewind",argv[n])){			if(device < 0 || device >= deviceCount){    		    fprintf(stderr,"tape number (%d) is out of range \n",device);		   				device = -1;			}			currentDevice = (io_object_t) CFArrayGetValueAtIndex(deviceArray,device);			if(currentDevice){	    			memset ( &scsiData, 0, sizeof ( struct scsiDataStruct ) );	    				    			scsiData.PrintLevel=0;	    								doDevice((io_service_t)currentDevice,&scsiData,RewindDevice);			}		}else if(!strcmp("fsf",argv[n]) || !strcmp("bsf",argv[n])){		    skipMarkType=SkipTapeMarks;Skip:		    ++n;			skipMarks = atoi(argv[n]);			if(!strcmp("bsf",argv[n-1]) || !strcmp("bsr",argv[n-1]))skipMarks = -skipMarks;			if(device < 0 || device >= deviceCount){    		    fprintf(stderr,"tape number (%d) is out of range \n",device);		   				device = -1;			}			currentDevice = (io_object_t) CFArrayGetValueAtIndex(deviceArray,device);			if(currentDevice){	    			memset ( &scsiData, 0, sizeof ( struct scsiDataStruct ) );	    				    			scsiData.PrintLevel=0;	    				    			scsiData.skipMarks=skipMarks;	    				    			scsiData.skipMarkType=skipMarkType;	    								doDevice((io_service_t)currentDevice,&scsiData,SkipDevice);			}		}else if(!strcmp("fsr",argv[n]) || !strcmp("bsr",argv[n])){		    skipMarkType=SkipDataBlocks;		    goto Skip;		}else if(!strcmp("-variable",argv[n])){		    	FixedBlock=0;		}else if(!strcmp("-fixed",argv[n])){		    	FixedBlock=1;		}else if(!strcmp("-blockcount",argv[n])){		    ++n;			BlockCount = atoi(argv[n]);			if(BlockCount <= 0){    		    fprintf(stderr,"BlockCount (%d) is out of range \n",device);		   				BlockCount = 20;			}		}else if(!strcmp("-blocksize",argv[n])){		    ++n;			BlockSizeRead = atoi(argv[n]);			if(BlockSizeRead < 0){    		    fprintf(stderr,"BlockSize (%d) is out of range \n",BlockSizeRead);		   				BlockSizeRead = 1024;			}						if(device < 0 || device >= deviceCount){    		    fprintf(stderr,"tape number (%d) is out of range \n",device);		   				device = -1;			}		}else if(!strcmp("setblk",argv[n])){		    ++n;			BlockSizeRead = atoi(argv[n]);			if(BlockSizeRead < 0){    		    fprintf(stderr,"BlockSize (%d) is out of range \n",BlockSizeRead);		   				BlockSizeRead = 1024;			}						if(device < 0 || device >= deviceCount){    		    fprintf(stderr,"tape number (%d) is out of range \n",device);		   				device = -1;			}						currentDevice = (io_object_t) CFArrayGetValueAtIndex(deviceArray,device);			if(currentDevice){	    			memset ( &scsiData, 0, sizeof ( struct scsiDataStruct ) );	    				    			scsiData.PrintLevel=0;	    				    			scsiData.FixedBlock=FixedBlock;	    				    			scsiData.BlockCount=BlockCount;	    				    			scsiData.BlockSizeRead=BlockSizeRead;	    				    								doDevice((io_service_t)currentDevice,&scsiData,SetBlockDevice);			}							}else if(!strcmp("read",argv[n])){			if(device < 0 || device >= deviceCount){    		    fprintf(stderr,"tape number (%d) is out of range \n",device);		   				device = -1;			}			currentDevice = (io_object_t) CFArrayGetValueAtIndex(deviceArray,device);			if(currentDevice){	    			memset ( &scsiData, 0, sizeof ( struct scsiDataStruct ) );	    				    			scsiData.PrintLevel=0;	    				    			scsiData.FixedBlock=FixedBlock;	    				    			scsiData.BlockCount=BlockCount;	    				    			scsiData.BlockSizeRead=BlockSizeRead;	    				    								scsiData.AskNextTape = AskNextTape;										doDevice((io_service_t)currentDevice,&scsiData,ReadDevice);			}		}else if(!strcmp("write",argv[n])){			if(device < 0 || device >= deviceCount){    		    fprintf(stderr,"tape number (%d) is out of range \n",device);		   				device = -1;			}			currentDevice = (io_object_t) CFArrayGetValueAtIndex(deviceArray,device);			if(currentDevice){	    			memset ( &scsiData, 0, sizeof ( struct scsiDataStruct ) );	    				    			scsiData.PrintLevel=0;	    				    			scsiData.FixedBlock=FixedBlock;	    				    			scsiData.BlockCount=BlockCount;	    				    			scsiData.BlockSizeRead=BlockSizeRead;	    				    			scsiData.writeMarks=writeMarks;	    				    								scsiData.AskNextTape = AskNextTape;										doDevice((io_service_t)currentDevice,&scsiData,WriteDevice);			}		}else if(!strcmp("-debug",argv[n])){		    ++n;			debug = atoi(argv[n]);		}else if(!strcmp("-asknexttape",argv[n])){		    ++n;			AskNextTape = atoi(argv[n]);		}else{    		fprintf(stderr,"Unknown Command %s\n",argv[n]);		                   }	}        	ret = 0;		for(index = 0; index < CFArrayGetCount(deviceArray); index++)	{		io_object_t		currentDevice = (io_object_t) CFArrayGetValueAtIndex(deviceArray, index) ;				IOObjectRelease(currentDevice) ;	}		return ret;}int WriteDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){	unsigned char *buff;	unsigned long buffSize;	    int ret;    ret = 0;                   Inquiry(interface,scsiData);           TestUnitReady(interface);                if(ReadBlockLimits(interface,scsiData))goto Done;        ModeSense6(interface,scsiData);    	if(scsiData->WriteProtect){	    fprintf(stderr,"WriteDevice Device WriteProtect\n");	    goto Done;	}		    buffSize=0x00FFFFFF;    if(buffSize > scsiData->MaxBlock)buffSize=scsiData->MaxBlock;    buff=(unsigned char *)malloc(buffSize);    if ( buff == NULL)    {        fprintf(stderr,"WriteDevice malloc %d failed\n",(int)buffSize);        goto Done;    }        ret=writeTapeBlocks(interface,buff,&buffSize,scsiData);    if(ret)goto Done;    ret = 0;        Done:    return ret;}int writeTapeBlocks(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData){    SCSITaskStatus taskStatus;    SCSI_Sense_Data senseData;    SCSICommandDescriptorBlock cdb;    SCSITaskInterface ** task = NULL;    IOReturn err = 0;    IOVirtualRange * range = NULL;    UInt64 transferCount = 0;    UInt32 SizeBuff,transfer,getbytes;        long long sum,sumb;    int retString;    int blks;    int ret;    int end;    char *msg;    int nreel;            if(!buff || !buffSize)return 1; // must have        ret = 0;        sum = 0;    sumb=0;    msg=NULL;    nreel=1;    range=NULL;    end = FALSE;    SizeBuff = *buffSize;        task = ( *interface )->CreateSCSITask ( interface );    if ( task != NULL )    {         range = ( IOVirtualRange * ) malloc ( sizeof ( IOVirtualRange ) );        if ( range == NULL ){msg="Mallocing IOVirtualRange";goto ErrorOut;}                range->address = ( IOVirtualAddress ) buff;        Start:				        memset ( &senseData, 0, sizeof ( senseData ) );                memset ( cdb, 0, sizeof ( cdb ) );                      cdb[0] = 0x0a;               if(scsiData->BlockSize > 0){           cdb[1] = 0x01;           getbytes=scsiData->BlockCount*scsiData->BlockSize;           retString=getString(buff,getbytes,stdin);           if(retString <= 0)goto ErrorOut;           sumb += retString;           if(retString != getbytes)end = TRUE;           blks=retString/scsiData->BlockSize;           if(blks*scsiData->BlockSize != retString)++blks;           transfer=blks*scsiData->BlockSize;        }else{           getbytes=scsiData->BlockSizeRead;           retString=getString(buff,getbytes,stdin);           if(retString <= 0)goto ErrorOut;           sumb += retString;           if(retString != getbytes)end = TRUE;           blks=transfer=scsiData->BlockSizeRead;        }Continue:        range->length = transfer;                if(debug > 1){                     fprintf(stderr,"transfer %d blks %d BlockSize %d BlockCount %d retString %d sumb %lld\n",(int)transfer,blks,(int)scsiData->BlockSize,scsiData->BlockCount,retString,sumb);		}                 cdb[2] = (blks >> 16) &  0xFF;        cdb[3] = (blks >> 8) &  0xFF;        cdb[4] = blks & 0xFF;                 err = ( *task )->SetCommandDescriptorBlock ( task, cdb,kSCSICDBSize_6Byte );        if ( err != kIOReturnSuccess ){msg="Setting CDB";goto ErrorOut;}        err = ( *task )->SetScatterGatherEntries ( task, range, 1, transfer,                                                    kSCSIDataTransfer_FromInitiatorToTarget);        if ( err != kIOReturnSuccess ){msg="SG Entries";goto ErrorOut;}                err = ( *task )->SetTimeoutDuration ( task, 100000 );        if ( err != kIOReturnSuccess ){msg="Setting Timeout";goto ErrorOut;}                       err = ( *task )->ExecuteTaskSync ( task, &senseData, &taskStatus, &transferCount );        if ( err != kIOReturnSuccess ){msg="Executing Task";goto ErrorOut;}                        sum += transferCount;                if(debug > 1){                      fprintf(stderr,"taskStatus = %d,transferCount = 0x%08llx, %08lld Total Bytes Written = %lld\n",                    taskStatus,transferCount,transferCount,sum);         }        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){	        if(scsiData->FixedBlock){	            if(transferCount != (scsiData->BlockSize*scsiData->BlockCount)){                	                fprintf(stderr,"taskStatus = %d Bytes Written = %lld Bytes Expected = %ld\n",	                    taskStatus, transferCount,(long)scsiData->BlockSize*scsiData->BlockCount);	            }	        }else{	            if(transferCount != scsiData->BlockSizeRead){                	                fprintf(stderr,"taskStatus = %d Bytes Written = %lld Bytes Expected = %ld\n",	                    taskStatus, transferCount,(long)scsiData->BlockSizeRead);	            }	        }		}                    if ( taskStatus == kSCSITaskStatus_GOOD && transferCount > 0 && !end)        {            goto Start;        }ErrorOut:        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){            PrintSenseString(&senseData);                        if((senseData.SENSE_KEY & 0x0F) == kSENSE_KEY_NO_SENSE &&               senseData.ADDITIONAL_SENSE_CODE == 0x00 &&               senseData.ADDITIONAL_SENSE_CODE_QUALIFIER == 0x01){                        ret = 2;  // tape mark            }            if((senseData.SENSE_KEY & 0x0F) == kSENSE_KEY_NO_SENSE &&               senseData.ADDITIONAL_SENSE_CODE == 0x00 &&               senseData.ADDITIONAL_SENSE_CODE_QUALIFIER == 0x02){                        ret = 3;  // end of media		          		          if(scsiData->AskNextTape && ttyin){		          		          				        char *c,bufftty[256]; 				        int n;		           		           	  ++nreel;        			  writeFileMarks(interface,1);		              rewindTape(interface);Redo:		              fprintf(stderr,"\n   At end of media - Load Reel %d To Write\n",nreel);		              fprintf(stderr,"          Enter 'continue' to continue \n");		              fprintf(stderr,"             Enter 'abort' to abort    \n");		           		              while(1){			              c=fgets(bufftty,255,ttyin);			              if(!c)continue;				          n=strlen(bufftty);				          if(n > 0)bufftty[n-1]=0;			              if(!strcmp(bufftty,"continue")){			                  fprintf(stderr,"Tape Loaded - Continue \n");				              rewindTape(interface);		    				  TestUnitReady(interface);		            		  if(transferCount == 0){		            		      goto Continue;		            		  }					        if(scsiData->FixedBlock){					            if(transferCount != (scsiData->BlockSize*scsiData->BlockCount)){                					                fprintf(stderr,"taskStatus = %d Bytes Written = %lld Bytes Expected = %ld\n",					                    taskStatus, transferCount,(long)scsiData->BlockSize*scsiData->BlockCount);					            }					            goto Start;					        }else{					            if(transferCount != scsiData->BlockSizeRead){                					                fprintf(stderr,"taskStatus = %d Bytes Written = %lld Bytes Expected = %ld\n",					                    taskStatus, transferCount,(long)scsiData->BlockSizeRead);					            }					            goto Start;					        }		            		  	            		  }else if(!strcmp(bufftty,"abort")){			                  fprintf(stderr,"Tape Load - Abort\n");			                  break;	            		  }else{			                  fprintf(stderr,"Unknown command %s \n",bufftty);			                  goto Redo;	            		  }            		  }            			          }else{		              fprintf(stderr,"writeTapeBlocks At end of media\n");		              fprintf(stderr,"Now what ?\n");		          }            }            if((senseData.SENSE_KEY & 0x0F) == kSENSE_KEY_BLANK_CHECK &&               senseData.ADDITIONAL_SENSE_CODE == 0x00 &&               senseData.ADDITIONAL_SENSE_CODE_QUALIFIER == 0x05){                        ret = 3;  // end of media                               }         }                    if(msg)fprintf(stderr,"***** WriteDevice Error %s *****\n",msg);                if(range)free ( range );                ( *task )->Release ( task );    }            if(scsiData->writeMarks){        writeFileMarks(interface,2);        skipTape(interface,-1,SkipTapeMarks);	}    return ret;}int getString(unsigned char *s,long n,FILE *in){	return fread(s,1,n,in);}int ReadDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){	unsigned char *buff;	unsigned long buffSize;	    int ret;    ret = 0;                Inquiry(interface,scsiData);           TestUnitReady(interface);        if(ReadBlockLimits(interface,scsiData))goto Done;        ModeSense6(interface,scsiData);        buffSize=0x00FFFFFF;    if(buffSize > scsiData->MaxBlock)buffSize=scsiData->MaxBlock;    buff=(unsigned char *)malloc(buffSize);    if ( buff == NULL)    {        fprintf(stderr,"malloc %d failed\n",(int)buffSize);        goto Done;    }        ret=readTapeBlocks(interface,buff,&buffSize,scsiData);    if(ret)goto Done;    ret = 0;        Done:    return ret;}int readTapeBlocks(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData){    SCSITaskStatus taskStatus;    SCSI_Sense_Data senseData;    SCSICommandDescriptorBlock cdb;    SCSITaskInterface ** task = NULL;    IOReturn err = 0;    IOVirtualRange * range = NULL;    UInt64 transferCount = 0;    UInt32 SizeBuff;        long long sum;    int blks;    int ret;    char *msg;    int nreel;            if(!buff || !buffSize)return 1; // must have        ret = 0;        sum = 0;    nreel=1;    msg=NULL;    range=NULL;    SizeBuff = *buffSize;        task = ( *interface )->CreateSCSITask ( interface );    if ( task != NULL )    {         range = ( IOVirtualRange * ) malloc ( sizeof ( IOVirtualRange ) );        if ( range == NULL ){msg="Mallocing IOVirtualRange";goto ErrorOut;}                range->address = ( IOVirtualAddress ) buff;        range->length = SizeBuff;        Start:       memset ( &senseData, 0, sizeof ( senseData ) );                memset ( cdb, 0, sizeof ( cdb ) );        memset ( buff, 0, sizeof ( buff ) );               cdb[0] = 0x08;               if(scsiData->FixedBlock){            cdb[1] = 0x01;           blks=scsiData->BlockCount;        }else{           blks=scsiData->BlockSizeRead;        }                         cdb[2] = (blks >> 16) &  0xFF;        cdb[3] = (blks >> 8) &  0xFF;        cdb[4] = blks & 0xFF;                 err = ( *task )->SetCommandDescriptorBlock ( task, cdb,kSCSICDBSize_6Byte );        if ( err != kIOReturnSuccess ){msg="Setting CDB";goto ErrorOut;}        err = ( *task )->SetScatterGatherEntries ( task, range, 1, SizeBuff,                                                    kSCSIDataTransfer_FromTargetToInitiator );        if ( err != kIOReturnSuccess ){msg="SG Entries";goto ErrorOut;}                err = ( *task )->SetTimeoutDuration ( task, 100000 );        if ( err != kIOReturnSuccess ){msg="Setting Timeout";goto ErrorOut;}                       err = ( *task )->ExecuteTaskSync ( task, &senseData, &taskStatus, &transferCount );        if ( err != kIOReturnSuccess ){msg="Executing Task";goto ErrorOut;}                        sum += transferCount;                if(debug > 1){             fprintf(stderr,"taskStatus = %d,transferCount = 0x%08llx , %08lld Total Bytes Read = %lld\n",                    taskStatus,transferCount,transferCount,sum);         }		          if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                    if(!(senseData.SENSE_KEY & 0x80) && (senseData.SENSE_KEY & 0x0F) != kSENSE_KEY_BLANK_CHECK){            		        if(scsiData->FixedBlock){		            if(transferCount != (scsiData->BlockSizeRead*scsiData->BlockCount)){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead*scsiData->BlockCount);		            }		        }else{		            if(transferCount != scsiData->BlockSizeRead){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead);		            }		        }	        }		}        if(transferCount > 0){            if(putString(buff,(long)transferCount,stdout))goto ErrorOut;        }                    if ( taskStatus == kSCSITaskStatus_GOOD && transferCount > 0)        {            goto Start;        }ErrorOut:        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                        if(isTapeMark(&senseData)){                    ret = 2;  // tape mark                       		if(debug){		       		fprintf(stderr,"readTapeBlocks Tape Mark (err %d) (sum %lld) (transferCount %lld)\n",err,sum,transferCount);		       	}		       		       if(scsiData->AskNextTape && ttyin && (sum > 0)){					struct Sensedata Sense;										cdb[2] = 0;			        cdb[3] = 0;			        cdb[4] = 1;			        err=readwriteSCSI(cdb,interface,buff,SizeBuff,ReadFromSCSI,&Sense);			        			         if(debug){               		 	PrintSenseString(&Sense.senseData);                		 	fprintf(stderr,"err %d (taskStatus %d) (transferCount %lld)\n",err,Sense.taskStatus,Sense.transferCount);               		 }			        if(isEOM(&Sense.senseData)){ 			          {		          		          					        char *c,bufftty[256]; 					        int n;			           			           	  ++nreel;			              rewindTape(interface);	Redo:			              fprintf(stderr,"\n   At end of media - Load Reel %d To Read\n",nreel);			              fprintf(stderr,"          Enter 'continue' to continue \n");			              fprintf(stderr,"             Enter 'abort' to abort    \n");			           			              while(1){				              c=fgets(bufftty,255,ttyin);				              if(!c)continue;					          n=strlen(bufftty);					          if(n > 0)bufftty[n-1]=0;				              if(!strcmp(bufftty,"continue")){				                  fprintf(stderr,"Tape Loaded - Continue \n");					              rewindTape(interface);			    				  TestUnitReady(interface);			            		  goto Start;		            		  }else if(!strcmp(bufftty,"abort")){				                  fprintf(stderr,"Tape Load - Abort\n");				                  break;		            		  }else{				                  fprintf(stderr,"Unknown command %s \n",bufftty);				                  goto Redo;		            		  }	            		  }	            	    }			           			        }else if(isTapeMark(&Sense.senseData)){			            skipTape(interface,-1,SkipTapeMarks);			            			         	if(debug)fprintf(stderr,"Backspace Tape Mark\n");			         				            if(Sense.transferCount > 0){					        skipTape(interface,-1,SkipDataBlocks);					        			         		if(debug)fprintf(stderr,"Backspace Data Block Also\n");			            }			        }else {					    skipTape(interface,-1,SkipDataBlocks);					    if(debug)fprintf(stderr,"Backspace Data Block\n");			         			           }		       }		                   }else if(isEOM(&senseData)){                    ret = 3;  // end of media               		       if(debug)fprintf(stderr,"readTapeBlocks end of media (sum %lld)\n",sum);		                      PrintSenseString(&senseData);            }else{            	PrintSenseString(&senseData);            }         }                    if(msg)fprintf(stderr,"***** readTape Error %s *****\n",msg);                if(range)free ( range );                ( *task )->Release ( task );    }        return ret;}int isTapeMark(SCSI_Sense_Data *senseData){	if(!senseData)return 0;	    if((senseData->SENSE_KEY & 0x0F) == kSENSE_KEY_NO_SENSE &&        senseData->ADDITIONAL_SENSE_CODE == 0x00 &&        senseData->ADDITIONAL_SENSE_CODE_QUALIFIER == 0x01){          return 1; // tape mark    }      return 0;}int isEOM(SCSI_Sense_Data *senseData){	if(!senseData)return 0;	    if((senseData->SENSE_KEY & 0x0F) == kSENSE_KEY_BLANK_CHECK &&        senseData->ADDITIONAL_SENSE_CODE == 0x00 &&        senseData->ADDITIONAL_SENSE_CODE_QUALIFIER == 0x05){                            return 1; // end of media    }      return 0;}int SkipDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){    int ret;    ret = 0;                Inquiry(interface,scsiData);           TestUnitReady(interface);       if(skipTape(interface,scsiData->skipMarks,scsiData->skipMarkType))goto Done;    sleep(5);    ret = 0;        Done:    return ret;}int RewindDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){    int ret;    ret = 0;                Inquiry(interface,scsiData);           TestUnitReady(interface);        rewindTape(interface);         sleep(1);        ret = 0;            return ret;}int AnalyzeDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){    int ret;    ret = 0;                Inquiry(interface,scsiData);           TestUnitReady(interface);        if(ReadBlockLimits(interface,scsiData))goto Done;        ModeSense6(interface,scsiData);        ReadPostion(interface,scsiData);        ret = 0;        Done:    return ret;}void ReadPostion(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){    unsigned char buff[255];    SCSICommandDescriptorBlock cdb;    unsigned long first,last;    int byte;        scsiData=scsiData;        memset ( cdb, 0, sizeof ( cdb ) );        	cdb[0] = 0x34;    /* Read Position Table 181 */	cdb[1] = 1;	if(!readwriteSCSI10(cdb,interface,buff,sizeof(buff),0,NULL)){      /* Table 182 */	   byte=buff[0];	   /* fprintf(stderr,"BOP %d EOP %d BPU %d\n",(byte & 0x80),(byte & 0x40),(byte & 0x04)); */ 	   if(!(byte & 0x04)){	       	   first=256L*256L*256L*(long)buff[4]+256L*256L*(long)buff[5]+256L*(long)buff[6]+(long)buff[7];	       	   last =256L*256L*256L*(long)buff[8]+256L*256L*(long)buff[9]+256L*(long)buff[10]+(long)buff[11];	           /* fprintf(stderr,"first %ld last %ld \n",first,last); */ 	           fprintf(stderr,"Block number %ld \n",first);	   }     	}}int AnalyzeDevices(io_service_t service,struct scsiDataStruct *scsiData){    IOCFPlugInInterface **plugInInterface = NULL;    SCSITaskDeviceInterface **interface = NULL;    kern_return_t err;    SInt32 score;    HRESULT herr;    int ret;    ret = 0;        err = IOCreatePlugInInterfaceForService ( service,                                                kIOSCSITaskDeviceUserClientTypeID,                                                kIOCFPlugInInterfaceID,                                                &plugInInterface,                                                &score );    if ( err != noErr )    {        fprintf(stderr,"IOCreatePlugInInterfaceForService returned %d\n", err);        goto Done3;            }    herr = ( *plugInInterface )->QueryInterface ( plugInInterface,                                                    CFUUIDGetUUIDBytes (                                                    kIOSCSITaskDeviceInterfaceID ),                                                    ( LPVOID ) &interface );    if ( herr != S_OK )    {        fprintf(stderr,"QueryInterface Error %ld\n",(long)herr);        goto Done2;            }            err = ( *interface )->ObtainExclusiveAccess ( interface );    if ( err != noErr )    {        fprintf(stderr,"ObtainExclusiveAccess Error %ld\n",(long)err);        goto Done2;            }            Inquiry(interface,scsiData);           TestUnitReady(interface);        if(ReadBlockLimits(interface,scsiData))goto Done;        ModeSense6(interface,scsiData);        ret = 0;        Done:    (*interface)->ReleaseExclusiveAccess(interface);        (*interface)->Release(interface);Done2:    IODestroyPlugInInterface(plugInInterface);Done3:        return ret;}void ModeSense6(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){    unsigned char buff[255];    SCSICommandDescriptorBlock cdb;    int pageCode;    int n;        memset ( cdb,  0, sizeof ( cdb ) );    memset ( buff, 0, sizeof ( buff ) );        	cdb[0] = 0x1A;    /* Mode Sense(6) */	cdb[2] = 0x3F;          /* return all pages */	cdb[2] = 0x3F | 0x40;   /* indicate changable parameters */	cdb[2] = 0x3F | 0x40;   /* indicate changable parameters */	cdb[4] = 255;		cdb[2] = 0x00;	cdb[4] = 12;	if(!readwriteSCSI(cdb,interface,buff,255,ReadFromSCSI,NULL)){                	   scsiData->Density=buff[4];	   scsiData->BufferMode=((buff[2] >> 4) & 7);	   scsiData->WriteProtect=(buff[2] & 0x80);	   scsiData->BlockSize=65536*buff[9]+256*buff[10]+buff[11];	   if(scsiData->PrintLevel)fprintf(stderr,"Density %d Buffer Mode %d Write Protect %d Block Size %d\n",	          (int)scsiData->Density,(int)scsiData->BufferMode,(int)scsiData->WriteProtect,(int)scsiData->BlockSize);	          	   n=12;	   while(n < buff[0]){	       pageCode = (buff[n] & 0x3f);	       fprintf(stderr,"Page type %d Page length %d\n",pageCode,buff[n+1]);	       if(pageCode == 0x10){  /* Table 200 */	           fprintf(stderr,"Active Format %d Active partition %d BIS %d\n",(buff[n+2] & 0x1F),	                          buff[n+3],(buff[n+8] & 0x40));	            	       }	       n += (2+buff[n+1]);	       	   }	}}int ReadBlockLimits(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){    unsigned char buff[255];    SCSICommandDescriptorBlock cdb;        memset ( cdb, 0, sizeof ( cdb ) );           	cdb[0] = 0x05 /* Read Block Limits */;	if(!readwriteSCSI(cdb,interface,buff,sizeof(buff),ReadFromSCSI,NULL)){                	    scsiData->MaxBlock=buff[3]+256*buff[2]+256*256*buff[1];	    	    scsiData->MinBlock=buff[5]+256*buff[4];	    	    if(scsiData->PrintLevel)fprintf(stderr,"MaxBlock %d MinBlock %d\n",(int)scsiData->MaxBlock,(int)scsiData->MinBlock);	}else{	    return 1;	}		return 0;}int skipTape(SCSITaskDeviceInterface **interface,int FileMarksToSkip,int type){    SCSICommandDescriptorBlock cdb;        memset ( cdb, 0, sizeof ( cdb ) );            cdb[0] = 0x11    /* SPACE COMMAND */;        if(type == SkipTapeMarks){    	cdb[1] = 0x01    /* Tape Marks */;    }else if(type == SkipDataBlocks){    	cdb[1] = 0x00    /* Data Blocks */;    }        cdb[2] = (FileMarksToSkip >> 16) & 0xFF;    cdb[3] = (FileMarksToSkip >> 8) & 0xFF;    cdb[4] =  FileMarksToSkip & 0xFF;	if(readwriteSCSI(cdb,interface,NULL,0L,ReadFromSCSI,NULL)){                	    return 1;	}		return 0;}int writeFileMarks(SCSITaskDeviceInterface **interface,int FileMarksToWrite){    SCSICommandDescriptorBlock cdb;        if(FileMarksToWrite <= 0){        fprintf(stderr,"writeFileMarks Error FileMarksToWrite %d\n",FileMarksToWrite);        return 1;    }        memset ( cdb, 0, sizeof ( cdb ) );            cdb[0] = 0x10    /* Write FileMarks COMMAND */;    cdb[1] = 0x00    /* do not return until done */;        cdb[2] = (FileMarksToWrite >> 16) & 0xFF;    cdb[3] = (FileMarksToWrite >> 8) & 0xFF;    cdb[4] =  FileMarksToWrite & 0xFF;                	if(readwriteSCSI(cdb,interface,NULL,0L,ReadFromSCSI,NULL)){                	    return 1;	}		return 0;}void rewindTape(SCSITaskDeviceInterface **interface){    SCSICommandDescriptorBlock cdb;            memset ( cdb, 0, sizeof ( cdb ) );            cdb[0] = 0x01;    /* Rewind */    cdb[1] = 0x00;    /* force wait */        cdb[4] = 0;	if(readwriteSCSI(cdb,interface,NULL,0L,ReadFromSCSI,NULL)){                	    return;	}		return;}void TestUnitReady(SCSITaskDeviceInterface **interface){	struct Sensedata Sense;    SCSI_Sense_Data senseData;    SCSICommandDescriptorBlock cdb;    int TryCount;          TryCount = 0;    TryAgain:        memset ( &Sense, 0, sizeof ( Sense ) );        memset ( cdb, 0, sizeof ( cdb ) );    	if(readwriteSCSI(cdb,interface,NULL,0L,ReadFromSCSI,&Sense)){  		        senseData=Sense.senseData;                         PrintSenseString(&senseData);                        if(senseData.SENSE_KEY == kSENSE_KEY_NOT_READY &&               senseData.ADDITIONAL_SENSE_CODE == 0x04 &&               senseData.ADDITIONAL_SENSE_CODE_QUALIFIER == 0x01){                           if(++TryCount <  5){                  fprintf(stderr,"Wait For Unit Ready\n");                  sleep(4);                  goto TryAgain;                }else{                  fprintf(stderr,"Wait Failed Unit Ready\n");              }            }               	}		return;}void Inquiry(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){    union scsi_data inqSCSI;    SCSICommandDescriptorBlock cdb;    char vendorID[9];    char productID[17];    char firmwareRevLevel[5];    UInt8 * bufPtr = ( UInt8 * ) &inqSCSI;    int index;        memset ( &vendorID, 0, sizeof ( vendorID ) );    memset ( &productID, 0, sizeof ( productID ) );    memset ( &firmwareRevLevel, 0, sizeof ( firmwareRevLevel ) );        memset ( cdb, 0, sizeof ( cdb ) );            cdb[0] = 0x12 /* inquiry */;    cdb[4] = sizeof (SCSICmd_INQUIRY_StandardData);	if(!readwriteSCSI(cdb,interface,(unsigned char *)&inqSCSI,sizeof (SCSICmd_INQUIRY_StandardData),ReadFromSCSI,NULL)){   #ifdef DEMO_VERSION        if(scsiData->PrintLevel)fprintf(stderr,"tuOSX 0.8 - beta 4 - Demo Version \n");#else        if(scsiData->PrintLevel)fprintf(stderr,"tuOSX 0.8 - beta 4\n");#endif        if(inqSCSI.scsi2.rdf == 0){            if(scsiData->PrintLevel)fprintf(stderr,"SCSI-1 InQuiry Format\n");        }else if (inqSCSI.scsi2.rdf == 2){            if(scsiData->PrintLevel)fprintf(stderr,"SCSI-2 InQuiry Format\n");        }else{           if(scsiData->PrintLevel)fprintf(stderr,"SCSI-2 InQuiry Format Type %d\n",inqSCSI.scsi2.rdf);        }                        if(inqSCSI.scsi2.sync){            if(scsiData->PrintLevel)fprintf(stderr,"Synchronous - IO Permittted\n");        }else{           if(scsiData->PrintLevel)fprintf(stderr,"Asynchronous - IO Only\n");        }                if(inqSCSI.scsi2.ansi == 1){            if(scsiData->PrintLevel)fprintf(stderr,"SCSI-1 Device\n");        }else if (inqSCSI.scsi2.ansi == 2){            if(scsiData->PrintLevel)fprintf(stderr,"SCSI-2 Device\n");        }else{           if(scsiData->PrintLevel)fprintf(stderr,"SCSI Device Type %d\n",inqSCSI.scsi2.ansi);        }                if(scsiData->PrintLevel){	        	        fprintf(stderr,"Peripheral Qualifier = %d\n", inqSCSI.scsi2.periph_qualifier);	         	        fprintf(stderr,"Peripheral Device Type = %d\n", inqSCSI.scsi2.dev_type);	       	        fprintf(stderr,"Removable Media Bit = %d\n", ( bufPtr[1] & 0x80 ) == 0x80);	        	        fprintf(stderr,"HISUP Media Bit = %d\n", ( bufPtr[3] & 0x10 ) == 0x10);        }                for ( index = 8; index < 16; index++ )        {            if ( bufPtr[index] == 0 )break;            vendorID[index-8] = bufPtr[index];        }        vendorID[index-8] = 0;        for ( index = 16; index < 32; index++ )        {            if ( bufPtr[index] == 0 )break;            productID[index-16] = bufPtr[index];        }        productID[index-16] = 0;        for ( index = 32; index < 36; index++ )                {            if ( bufPtr[index] == 0 )break;            firmwareRevLevel[index-32] = bufPtr[index];        }        firmwareRevLevel[index-32] = 0;                if(scsiData->PrintLevel){	        	        	        fprintf(stderr,"Vendor Identification = %s\n", ( char * ) vendorID);	        fprintf(stderr,"Product Identification = %s\n", ( char * ) productID);	        fprintf(stderr,"Product Revision Level = %s\n", ( char * )firmwareRevLevel);        }     	strncpy(scsiData->vendorIDFound,vendorID,64);        eatSpaces(scsiData->vendorIDFound);     	strncpy(scsiData->productIDFound,productID,64);        eatSpaces(scsiData->productIDFound);     	strncpy(scsiData->firmwareRevLevelFound,firmwareRevLevel,64);        eatSpaces(scsiData->firmwareRevLevelFound);	}}int eatSpaces(char *name){    int n;        if(!name)return 1;       for(n=strlen(name)-1;n > 0;--n){        if(name[n] == ' '){            name[n]=0;        }else{            break;        }    }        return 0;}void PrintSenseString ( SCSI_Sense_Data * sense ){    UInt8 key, ASC, ASCQ;    char str[256];           key = sense->SENSE_KEY & 0x0F;    ASC = sense->ADDITIONAL_SENSE_CODE;    ASCQ = sense->ADDITIONAL_SENSE_CODE_QUALIFIER;    if(key == 0x06 && ASC == 0x28 && ASCQ == 0x00){        fprintf(stderr,"Tape Loaded \n");    }else if(key == 0x02 && ASC == 0x04 && ASCQ == 0x01){        fprintf(stderr,"Unit Not Ready \n");    }else if(key == 0x02 && ASC == 0x3a && ASCQ == 0x00){        fprintf(stderr,"No Media in Unit \n");    }else{        fprintf(stderr,"Key: $%02x, ASC: $%02x, ASCQ: $%02x \n", key, ASC, ASCQ);    }        str[0] = '\0';    switch (key) {        case kSENSE_KEY_NO_SENSE: 		strcat(str, "No Sense"); break;        case kSENSE_KEY_RECOVERED_ERROR: 	strcat(str, "Recovered Error"); break;        case kSENSE_KEY_NOT_READY: 		strcat(str, "Not Ready"); break;        case kSENSE_KEY_MEDIUM_ERROR: 		strcat(str, "Medium Error"); break;        case kSENSE_KEY_HARDWARE_ERROR: 	strcat(str, "Hardware Error"); break;        case kSENSE_KEY_ILLEGAL_REQUEST: 	strcat(str, "Illegal Request"); break;        case kSENSE_KEY_UNIT_ATTENTION: 	strcat(str, "Unit Attention"); break;        case kSENSE_KEY_DATA_PROTECT: 		strcat(str, "Data Protect"); break;        case kSENSE_KEY_BLANK_CHECK: 		strcat(str, "Blank Check"); break;        case kSENSE_KEY_VENDOR_SPECIFIC: 	strcat(str, "Vendor Specific"); break;        case kSENSE_KEY_COPY_ABORTED: 		strcat(str, "Copy Aborted"); break;        case kSENSE_KEY_ABORTED_COMMAND: 	strcat(str, "Aborted Command"); break;        case 0xC: 				strcat(str, "Equal (now obsolete)"); break;        case kSENSE_KEY_VOLUME_OVERFLOW: 	strcat(str, "Volume Overflow"); break;        case kSENSE_KEY_MISCOMPARE: 		strcat(str, "Miscompare"); break;        default: 				strcat(str, "Unknown Sense Code"); break;    }        strcat(str, ", " );        switch (((UInt16) ASC << 8) | ASCQ) {        case 0x0000: strcat(str, "No additional sense information"); break;        case 0x0001: strcat(str, "Filemark detected"); break;        case 0x0002: strcat(str, "End of partition/medium detected"); break;        case 0x0003: strcat(str, "Setmark detected"); break;        case 0x0004: strcat(str, "Beginning of partition/medium detected"); break;        case 0x0005: strcat(str, "End of data detected"); break;        case 0x0006: strcat(str, "I/O process termination"); break;        case 0x0011: strcat(str, "Play operation in progress"); break;        case 0x0012: strcat(str, "Play operation paused"); break;        case 0x0013: strcat(str, "Play operation successfully completed"); break;        case 0x0014: strcat(str, "Play operation stopped due to error"); break;        case 0x0015: strcat(str, "No current audio status to return"); break;        case 0x0016: strcat(str, "Operation in progress"); break;        case 0x0017: strcat(str, "Cleaning requested"); break;        case 0x0100: strcat(str, "Mechanical positioning or changer error"); break;        case 0x0200: strcat(str, "No seek complete"); break;        case 0x0300: strcat(str, "Peripheral device write fault"); break;        case 0x0301: strcat(str, "No write current"); break;        case 0x0302: strcat(str, "Excessive write errors"); break;        case 0x0400: strcat(str, "Logical unit not ready, cause not reportable"); break;        case 0x0401: strcat(str, "Logical unit not ready, in process of becoming ready"); break;        case 0x0402: strcat(str, "Logical unit not ready, initializing command required"); break;        case 0x0403: strcat(str, "Logical unit not ready, manual intervention required"); break;        case 0x0404: strcat(str, "Logical unit not ready, format in progress"); break;        case 0x0407: strcat(str, "Logical unit not ready, operation in progress"); break;        case 0x0408: strcat(str, "Logical unit not ready, long write in progress"); break;        case 0x0409: strcat(str, "Logical unit not ready, self-test in progress"); break;        case 0x0500: strcat(str, "Logical unit does not respond to selection"); break;        case 0x0501: strcat(str, "Media load - Eject failed"); break;        case 0x0600: strcat(str, "No reference position found"); break;        case 0x0700: strcat(str, "Multiple peripheral devices selected"); break;        case 0x0800: strcat(str, "Logical unit communication failure"); break;        case 0x0801: strcat(str, "Logical unit communication time-out"); break;        case 0x0802: strcat(str, "Logical unit communication parity error"); break;        case 0x0803: strcat(str, "Logical unit communication CRC error (Ultra-DMA/32)"); break;        case 0x0804: strcat(str, "Unreachable copy target"); break;        case 0x0900: strcat(str, "Track following error"); break;        case 0x0901: strcat(str, "Tracking servo failure"); break;        case 0x0902: strcat(str, "Focus servo failure"); break;        case 0x0903: strcat(str, "Spindle servo failure"); break;        case 0x0904: strcat(str, "Head select fault"); break;        case 0x0A00: strcat(str, "Error log overflow"); break;        case 0x0B00: strcat(str, "Warning"); break;        case 0x0B01: strcat(str, "Warning, specified temperature exceeded"); break;        case 0x0B02: strcat(str, "Warning, enclosure degraded"); break;        case 0x0C00: strcat(str, "Write error"); break;        case 0x0C01: strcat(str, "Write error, recovered with auto reallocation"); break;        case 0x0C02: strcat(str, "Write error, auto reallocation failed"); break;        case 0x0C03: strcat(str, "Write error, recommend reassignment"); break;        case 0x0C04: strcat(str, "Compression check miscompare error"); break;        case 0x0C05: strcat(str, "Data expansion occurred during compression"); break;        case 0x0C06: strcat(str, "Block not compressible"); break;        case 0x0C07: strcat(str, "Write error, recovery needed"); break;        case 0x0C08: strcat(str, "Write error, recovery failed"); break;        case 0x0C09: strcat(str, "Write error, loss of streaming"); break;        case 0x0C0A: strcat(str, "Write error, padding blocks added"); break;        case 0x1000: strcat(str, "ID, CRC or ECC error"); break;        case 0x1100: strcat(str, "Unrecovered read error"); break;        case 0x1101: strcat(str, "Read retries exhausted"); break;        case 0x1102: strcat(str, "Error too long to correct"); break;        case 0x1103: strcat(str, "Multiple read errors"); break;        case 0x1104: strcat(str, "Unrecovered read error - auto reallocate failed"); break;        case 0x1105: strcat(str, "L-EC uncorrectable error"); break;        case 0x1106: strcat(str, "CIRC unrecovered error"); break;        case 0x1107: strcat(str, "Re-synchronization error"); break;        case 0x1108: strcat(str, "Incomplete block read"); break;        case 0x1109: strcat(str, "No gap found"); break;        case 0x110A: strcat(str, "Miscorrected error"); break;        case 0x110B: strcat(str, "Unrecovered read error - recommend reassignment"); break;        case 0x110C: strcat(str, "Unrecovered read error - recommend rewrite the data"); break;        case 0x110D: strcat(str, "De-compression CRC error"); break;        case 0x110E: strcat(str, "Cannot decompress using declared algorithm"); break;        case 0x110F: strcat(str, "Error reading UPC/EAN number"); break;        case 0x1110: strcat(str, "Error reading ISRC number"); break;        case 0x1111: strcat(str, "Read error, loss of streaming"); break;        case 0x1200: strcat(str, "Address mark not found for ID field"); break;        case 0x1300: strcat(str, "Address mark not found for data field"); break;        case 0x1400: strcat(str, "Recorded entity not found"); break;        case 0x1401: strcat(str, "Record not found"); break;        case 0x1402: strcat(str, "Filemark or setmark not found"); break;        case 0x1403: strcat(str, "End of data not found"); break;        case 0x1404: strcat(str, "Block sequence error"); break;        case 0x1405: strcat(str, "Record not found - recommend reassignment"); break;        case 0x1406: strcat(str, "Record not found - data auto-reallocated"); break;        case 0x1500: strcat(str, "Random positioning error"); break;        case 0x1501: strcat(str, "Mechanical positioning or changer error"); break;        case 0x1502: strcat(str, "Positioning error detected by read of medium"); break;        case 0x1600: strcat(str, "Data synchronization mark error"); break;        case 0x1601: strcat(str, "Data sync error - data rewritten"); break;        case 0x1602: strcat(str, "Data sync error - recommend rewrite"); break;        case 0x1603: strcat(str, "Data sync error - data auto-reallocated"); break;        case 0x1604: strcat(str, "Data sync error - recommend reassignment"); break;        case 0x1700: strcat(str, "Recovered data with no error correction applied"); break;        case 0x1701: strcat(str, "Recovered data with retries"); break;        case 0x1702: strcat(str, "Recovered data with positive head offset"); break;        case 0x1703: strcat(str, "Recovered data with negative head offset"); break;        case 0x1704: strcat(str, "Recovered data with retries and/or CIRC applied"); break;        case 0x1705: strcat(str, "Recovered data using previous sector ID"); break;        case 0x1706: strcat(str, "Recovered data without ECC, data auto-reallocated"); break;        case 0x1707: strcat(str, "Recovered data without ECC, recommend reassignment"); break;        case 0x1708: strcat(str, "Recovered data without ECC, recommend rewrite"); break;        case 0x1709: strcat(str, "Recivered data without ECC, data rewritten"); break;        case 0x1800: strcat(str, "Recovered data with error correction applied"); break;        case 0x1801: strcat(str, "Recovered data with error correction & retries applied"); break;        case 0x1802: strcat(str, "Recovered data, the data was auto-reallocated"); break;        case 0x1803: strcat(str, "Recovered data with CIRC"); break;        case 0x1804: strcat(str, "Recovered data with L-EC"); break;        case 0x1805: strcat(str, "Recovered data, recommend reassignment"); break;        case 0x1806: strcat(str, "Recovered data, recommend rewrite"); break;        case 0x1807: strcat(str, "Recovered data with ECC, data rewritten"); break;        case 0x1808: strcat(str, "Recovered data with linking"); break;        case 0x1900: strcat(str, "Defect list error"); break;        case 0x1901: strcat(str, "Defect list not available"); break;        case 0x1902: strcat(str, "Defect list error in primary list"); break;        case 0x1903: strcat(str, "Defect list error in grown list"); break;        case 0x1A00: strcat(str, "Parameter list length error"); break;        case 0x1B00: strcat(str, "Synchronous data transfer error"); break;        case 0x1C00: strcat(str, "Defect list not found"); break;        case 0x1C01: strcat(str, "Primary defect list not found"); break;        case 0x1C02: strcat(str, "Grown defect list not found"); break;        case 0x1D00: strcat(str, "Miscompare during verify operation"); break;        case 0x1E00: strcat(str, "Recovered ID with ECC correction"); break;        case 0x1F00: strcat(str, "Partial defect list transfer"); break;        case 0x2000: strcat(str, "Invalid command operation code"); break;        case 0x2100: strcat(str, "Logical block address out of range"); break;        case 0x2101: strcat(str, "Invalid element address"); break;        case 0x2102: strcat(str, "Invalid address for write"); break;        case 0x2200: strcat(str, "Illegal function"); break;        case 0x2400: strcat(str, "Invalid field in CDB"); break;        case 0x2401: strcat(str, "CDB decryption error"); break;        case 0x2500: strcat(str, "Logical unit not supported"); break;        case 0x2600: strcat(str, "Invalid field in parameter list"); break;        case 0x2601: strcat(str, "Parameter not supported"); break;        case 0x2602: strcat(str, "Parameter value invalid"); break;        case 0x2603: strcat(str, "Threshold parameters not supported"); break;        case 0x2604: strcat(str, "Invalid release of active persistent reservation"); break;        case 0x2605: strcat(str, "Data decryption error"); break;        case 0x2606: strcat(str, "Too many target descriptors"); break;        case 0x2607: strcat(str, "Unsupported target descriptor type code"); break;        case 0x2608: strcat(str, "Too many segment descriptors"); break;        case 0x2609: strcat(str, "Unsupported segment descriptor type code"); break;        case 0x260A: strcat(str, "Unexpected inexact segment"); break;        case 0x260B: strcat(str, "Inline data length exceeded"); break;        case 0x260C: strcat(str, "Invalid operation for copy source or destination"); break;        case 0x260D: strcat(str, "Copy segment granularity violation"); break;        case 0x2700: strcat(str, "Write protected"); break;        case 0x2701: strcat(str, "Hardware write protected"); break;        case 0x2702: strcat(str, "Logical unit software write protected"); break;        case 0x2703: strcat(str, "Associated write protect"); break;        case 0x2704: strcat(str, "Persistent write protect"); break;        case 0x2705: strcat(str, "Permanent write protect"); break;        case 0x2800: strcat(str, "Not ready to ready transition, medium may have changed"); break;        case 0x2801: strcat(str, "Import or export element accessed"); break;        case 0x2900: strcat(str, "Power on, reset or bus device reset occurred"); break;        case 0x2901: strcat(str, "Power on occured"); break;        case 0x2902: strcat(str, "SCSI bus reset occurred"); break;        case 0x2903: strcat(str, "Bus device reset function occurred"); break;        case 0x2904: strcat(str, "Device internal reset"); break;        case 0x2905: strcat(str, "Transceiver mode changed to single-ended"); break;        case 0x2906: strcat(str, "Transceiver mode changed to LVD"); break;        case 0x2A00: strcat(str, "Parameters changed"); break;        case 0x2A01: strcat(str, "Mode parameters changed"); break;        case 0x2A02: strcat(str, "Log parameters changed"); break;        case 0x2A03: strcat(str, "Reservations preempted"); break;        case 0x2A04: strcat(str, "Reservations released"); break;        case 0x2A05: strcat(str, "Registrations preempted"); break;        case 0x2B00: strcat(str, "Copy cannot execute since host cannot disconnect"); break;        case 0x2C00: strcat(str, "Command sequence error"); break;        case 0x2C01: strcat(str, "Too many windows specified"); break;        case 0x2C02: strcat(str, "Invalid combination of windows specified"); break;        case 0x2C03: strcat(str, "Current program area is not empty"); break;        case 0x2C04: strcat(str, "Current program area is empty"); break;        case 0x2C05: strcat(str, "Persistent prevent conflict"); break;        case 0x2D00: strcat(str, "Overwrite error on update in place"); break;        case 0x2E00: strcat(str, "Insufficient time for operation"); break;        case 0x2F00: strcat(str, "Commands cleared by anther initiator"); break;        case 0x3000: strcat(str, "Incompatible medium installed"); break;        case 0x3001: strcat(str, "Cannot read medium, unknown format"); break;        case 0x3002: strcat(str, "Cannot read medium, incompatible format"); break;        case 0x3003: strcat(str, "Cleaning cartridge installed"); break;        case 0x3004: strcat(str, "Cannot write medium, unknown format"); break;        case 0x3005: strcat(str, "Cannot write medium, incompatible format"); break;        case 0x3006: strcat(str, "Cannot format medium, incompatible medium"); break;        case 0x3007: strcat(str, "Cleaning failure"); break;        case 0x3008: strcat(str, "Cannot write, application code mismatch"); break;        case 0x3009: strcat(str, "Current session not fixated for append"); break;        case 0x3100: strcat(str, "Medium format corrupted"); break;        case 0x3101: strcat(str, "Format command failed"); break;        case 0x3102: strcat(str, "Zoned formatting failed due to spare linking"); break;        case 0x3200: strcat(str, "No defect spare location available"); break;        case 0x3201: strcat(str, "Defect list update failure"); break;        case 0x3300: strcat(str, "Tape length error"); break;        case 0x3400: strcat(str, "Enclosure failure"); break;        case 0x3500: strcat(str, "Enclosure services failure"); break;        case 0x3501: strcat(str, "Unsupported enclosure function"); break;        case 0x3502: strcat(str, "Enclosure services unavailable"); break;        case 0x3503: strcat(str, "Enclosure services transfer failure"); break;        case 0x3504: strcat(str, "Enclosure services transfer refused"); break;        case 0x3600: strcat(str, "Ribbon, ink, or toner failure"); break;        case 0x3700: strcat(str, "Rounded parameter"); break;        case 0x3800: strcat(str, "Event status notification"); break;        case 0x3802: strcat(str, "ESN - Power management class event"); break;        case 0x3804: strcat(str, "ESN - Media class event"); break;        case 0x3806: strcat(str, "ESN - Device busy class event"); break;        case 0x3900: strcat(str, "Saving parameters not supported"); break;        case 0x3A00: strcat(str, "Medium not present"); break;        case 0x3A01: strcat(str, "Medium not present, tray closed"); break;        case 0x3A02: strcat(str, "Medium not present, tray open"); break;        case 0x3A03: strcat(str, "Medium not present, loadable"); break;        case 0x3A04: strcat(str, "Medium not present, medium auxiliary memory accessible"); break;        case 0x3B00: strcat(str, "Sequential positioning error"); break;        case 0x3B01: strcat(str, "Tape position error at beginning of medium"); break;        case 0x3B02: strcat(str, "Tape position error at end of medium"); break;        case 0x3B03: strcat(str, "Tape or electronic vertical forms unit not ready"); break;        case 0x3B04: strcat(str, "Slew failure"); break;        case 0x3B05: strcat(str, "Paper jam"); break;        case 0x3B06: strcat(str, "Failed to sense top-of-form"); break;        case 0x3B07: strcat(str, "Failed to sense bottom-of-form"); break;        case 0x3B08: strcat(str, "Reposition error"); break;        case 0x3B09: strcat(str, "Read past end of medium"); break;        case 0x3B0A: strcat(str, "Read past beginning of medium"); break;        case 0x3B0B: strcat(str, "Position past end of medium"); break;        case 0x3B0C: strcat(str, "Position past beginning of medium"); break;        case 0x3B0D: strcat(str, "Medium destination element full"); break;        case 0x3B0E: strcat(str, "Medium source element empty"); break;        case 0x3B0F: strcat(str, "End of medium reached"); break;        case 0x3B11: strcat(str, "Medium magazine not accessible"); break;        case 0x3B12: strcat(str, "Medium magazine removed"); break;        case 0x3B13: strcat(str, "Medium magazine inserted"); break;        case 0x3B14: strcat(str, "Medium magazine locked"); break;        case 0x3B15: strcat(str, "Medium magazine unlocked"); break;        case 0x3B16: strcat(str, "Mechanical positioning or changer error"); break;        case 0x3D00: strcat(str, "Invalid bits in identify message"); break;        case 0x3E00: strcat(str, "Logical unit has not self-configured yet"); break;        case 0x3E01: strcat(str, "Logical unit failure"); break;        case 0x3E02: strcat(str, "Timeout on logical unit"); break;        case 0x3E03: strcat(str, "Logical unit failed self-test"); break;        case 0x3E04: strcat(str, "Logical unit unable to update self-test log"); break;        case 0x3F00: strcat(str, "Target operating conditions have changed"); break;        case 0x3F01: strcat(str, "Microcode has been changed"); break;        case 0x3F02: strcat(str, "Changed operating definition"); break;        case 0x3F03: strcat(str, "Inquiry data has changed"); break;        case 0x3F04: strcat(str, "Component device attached"); break;        case 0x3F05: strcat(str, "Device identifier changed"); break;        case 0x3F06: strcat(str, "Redundancy group created or modified"); break;        case 0x3F07: strcat(str, "Redundancy group deleted"); break;        case 0x3F08: strcat(str, "Spare created or modified"); break;        case 0x3F09: strcat(str, "Spare deleted"); break;        case 0x3F0A: strcat(str, "Volume set created or modified"); break;        case 0x3F0B: strcat(str, "Volume set deleted"); break;        case 0x3F0C: strcat(str, "Volume set deassigned"); break;        case 0x3F0D: strcat(str, "Volume set reassigned"); break;        case 0x3F0E: strcat(str, "Reported LUNs data has changed"); break;        case 0x3F10: strcat(str, "Medium loadable"); break;        case 0x3F11: strcat(str, "Medium auxiliary memory accessible"); break;        case 0x4000: strcat(str, "RAM failure"); break;        case 0x4100: strcat(str, "Data path failure"); break;        case 0x4200: strcat(str, "Power-on or self-test failure"); break;        case 0x4300: strcat(str, "Message error"); break;        case 0x4400: strcat(str, "Internal target failure"); break;        case 0x4500: strcat(str, "Select or reselect failure"); break;        case 0x4600: strcat(str, "Unseccessful soft reset"); break;        case 0x4700: strcat(str, "SCSI Parity error"); break;        case 0x4701: strcat(str, "Data phase CRC error detected"); break;        case 0x4702: strcat(str, "SCSI parity error detected during ST data phase"); break;        case 0x4703: strcat(str, "Information unit CRC error detected"); break;        case 0x4704: strcat(str, "Async information protection error detected"); break;        case 0x4800: strcat(str, "Initiator detected error message received"); break;        case 0x4900: strcat(str, "Invalid message error"); break;        case 0x4A00: strcat(str, "Command phase error"); break;        case 0x4B00: strcat(str, "Data phase error"); break;        case 0x4C00: strcat(str, "Logical unit failed self-configuration"); break;        case 0x4E00: strcat(str, "Overlapped commands attempted"); break;        case 0x5000: strcat(str, "Write append error"); break;        case 0x5001: strcat(str, "Write append position error"); break;        case 0x5002: strcat(str, "Position error related to timing"); break;        case 0x5100: strcat(str, "Erase failure"); break;        case 0x5300: strcat(str, "Media load or eject failed"); break;        case 0x5301: strcat(str, "Unload tape failure"); break;        case 0x5302: strcat(str, "Medium removal prevented"); break;        case 0x5400: strcat(str, "SCSI to host system interface failure"); break;        case 0x5500: strcat(str, "System Resource failure"); break;        case 0x5501: strcat(str, "System Buffer full"); break;        case 0x5502: strcat(str, "Insufficient reservation resources"); break;        case 0x5503: strcat(str, "Insufficient resources"); break;        case 0x5504: strcat(str, "Insufficient registration resources"); break;        case 0x5700: strcat(str, "Unable to recover table of contents"); break;        case 0x5800: strcat(str, "Generation does not exist"); break;        case 0x5900: strcat(str, "Updated block read"); break;        case 0x5A00: strcat(str, "Operator request or state change input (UNSPECIFIED)"); break;        case 0x5A01: strcat(str, "Operator medium removal request"); break;        case 0x5A02: strcat(str, "Operator selected write protect"); break;        case 0x5A03: strcat(str, "Operator selected write permit"); break;        case 0x5B00: strcat(str, "Log exception"); break;        case 0x5B01: strcat(str, "Threshold condition met"); break;        case 0x5B02: strcat(str, "Log counter at maximum"); break;        case 0x5B03: strcat(str, "Log list codes exhausted"); break;        case 0x5C00: strcat(str, "RPL status change"); break;        case 0x5C01: strcat(str, "Spindles synchronized"); break;        case 0x5C02: strcat(str, "Spindle not synchronized"); break;        case 0x5D00: strcat(str, "Failure prediction threshold exceeded, predicted logical unit failure"); break;        case 0x5D01: strcat(str, "Failure prediction threshold exceeded, predicted media failure"); break;        case 0x5D10: strcat(str, "Hardware impending failure - general hard drive failure"); break;        case 0x5D11: strcat(str, "Hardware impending failure - drive error rate too high"); break;        case 0x5D12: strcat(str, "Hardware impending failure - data error rate too high"); break;        case 0x5D13: strcat(str, "Hardware impending failure - seek error rate too high"); break;        case 0x5D14: strcat(str, "Hardware impending failure - too many block reassigns"); break;        case 0x5D15: strcat(str, "Hardware impending failure - access times too high"); break;        case 0x5D16: strcat(str, "Hardware impending failure - start unit times too high"); break;        case 0x5D17: strcat(str, "Hardware impending failure - channel parametrics"); break;        case 0x5D18: strcat(str, "Hardware impending failure - controller detected"); break;        case 0x5D19: strcat(str, "Hardware impending failure - throughput performance"); break;        case 0x5D1A: strcat(str, "Hardware impending failure - seek time performance"); break;        case 0x5D1B: strcat(str, "Hardware impending failure - spin-up retry count"); break;        case 0x5D1C: strcat(str, "Hardware impending failure - drive calibration retry count"); break;        case 0x5D20: strcat(str, "Controller impending failure - general hard drive failure"); break;        case 0x5D21: strcat(str, "Controller impending failure - drive error rate too high"); break;        case 0x5D22: strcat(str, "Controller impending failure - data error rate too high"); break;        case 0x5D23: strcat(str, "Controller impending failure - seek error rate too high"); break;        case 0x5D24: strcat(str, "Controller impending failure - too many block reassigns"); break;        case 0x5D25: strcat(str, "Controller impending failure - access times too high"); break;        case 0x5D26: strcat(str, "Controller impending failure - start unit times too high"); break;        case 0x5D27: strcat(str, "Controller impending failure - channel parametrics"); break;        case 0x5D28: strcat(str, "Controller impending failure - controller detected"); break;        case 0x5D29: strcat(str, "Controller impending failure - throughput performance"); break;        case 0x5D2A: strcat(str, "Controller impending failure - seek time performance"); break;        case 0x5D2B: strcat(str, "Controller impending failure - spin-up retry count"); break;        case 0x5D2C: strcat(str, "Controller impending failure - drive calibration retry count"); break;        case 0x5DFF: strcat(str, "Failure prediction threshold exceeded (FALSE)"); break;        case 0x5E00: strcat(str, "Low power condition on"); break;        case 0x5E01: strcat(str, "Idle condition activated by timer"); break;        case 0x5E02: strcat(str, "Standby condition activated by timer"); break;        case 0x5E03: strcat(str, "Idle condition activated by command"); break;        case 0x5E04: strcat(str, "Standby condition activated by command"); break;        case 0x5E41: strcat(str, "Power state change to active"); break;        case 0x5E42: strcat(str, "Power state change to idle"); break;        case 0x5E43: strcat(str, "Power state change to standby"); break;        case 0x5E45: strcat(str, "Power state change to sleep"); break;        case 0x5E47: strcat(str, "Power state change to device control"); break;        case 0x6000: strcat(str, "Lamp failure"); break;        case 0x6100: strcat(str, "Video acquisition error"); break;        case 0x6101: strcat(str, "Unable to acquire video"); break;        case 0x6102: strcat(str, "Out of focus"); break;        case 0x6200: strcat(str, "Scan head positioning error"); break;        case 0x6300: strcat(str, "End of user area encountered on this track"); break;        case 0x6301: strcat(str, "Packet does not fit in available space"); break;        case 0x6400: strcat(str, "Illegal mode for this track or incompatible medium"); break;        case 0x6401: strcat(str, "Invalid packet size"); break;        case 0x6500: strcat(str, "Voltage fault"); break;        case 0x6600: strcat(str, "Automatic document feeder cover up"); break;        case 0x6601: strcat(str, "Automatic document feeder lift up"); break;        case 0x6602: strcat(str, "Document jam in automatic document feeder"); break;        case 0x6603: strcat(str, "Document misfeed in automatic document feeder"); break;        case 0x6700: strcat(str, "Configuration failure"); break;        case 0x6701: strcat(str, "Configuration of incapable logical unit"); break;        case 0x6702: strcat(str, "Add logical unit failed"); break;        case 0x6703: strcat(str, "Modification of logical unit failed"); break;        case 0x6704: strcat(str, "Exchange of logical unit failed"); break;        case 0x6705: strcat(str, "Remove of logical unit failed"); break;        case 0x6706: strcat(str, "Attachment of logical unit failed"); break;        case 0x6707: strcat(str, "Creation of logical unit failed"); break;        case 0x6800: strcat(str, "Logical unit not configured"); break;        case 0x6900: strcat(str, "Data loss on logical unit"); break;        case 0x6901: strcat(str, "Multiple logical unit failures"); break;        case 0x6902: strcat(str, "A parity/data mismatch"); break;        case 0x6A00: strcat(str, "Informational, refer to log"); break;        case 0x6B00: strcat(str, "State change has occurred"); break;        case 0x6B01: strcat(str, "Redundancy level got better"); break;        case 0x6B02: strcat(str, "Redundancy level got worse"); break;        case 0x6C00: strcat(str, "Rebuild failure occurred"); break;        case 0x6D00: strcat(str, "Recalculate failure occurred"); break;        case 0x6E00: strcat(str, "Command to logical unit failed"); break;        case 0x6F00: strcat(str, "Copy protection key exchange failure, authentication failure"); break;        case 0x6F01: strcat(str, "Copy protection key exchange failure, key not present"); break;        case 0x6F02: strcat(str, "Copy protection key exchange failure, key not established"); break;        case 0x6F03: strcat(str, "Read of scrambled sector without authentication"); break;        case 0x6F04: strcat(str, "Media region code is mismatched to logical unit region"); break;        case 0x6F05: strcat(str, "Drive region must be permanent/Region reset count error"); break;        case 0x7100: strcat(str, "Decompression exception long algorithm id"); break;        case 0x7200: strcat(str, "Session fixation error"); break;        case 0x7201: strcat(str, "Session fixation error writing lead-in"); break;        case 0x7202: strcat(str, "Session fixation error writing lead-out"); break;        case 0x7203: strcat(str, "Session fixation error, incomplete track in session"); break;        case 0x7204: strcat(str, "Empty or partially written reserved track"); break;        case 0x7205: strcat(str, "No more RZone reservations are allowed"); break;        case 0x7300: strcat(str, "CD control error"); break;        case 0x7301: strcat(str, "Power calibration area almost full"); break;        case 0x7302: strcat(str, "Power calibration area is full"); break;        case 0x7303: strcat(str, "Power calibration area error"); break;        case 0x7304: strcat(str, "Program memory area update failure"); break;        case 0x7305: strcat(str, "Program memory area is full"); break;        case 0x7306: strcat(str, "Program memory area is (almost) full"); break;        case 0xB900: strcat(str, "Play operation aborted"); break;        case 0xBF00: strcat(str, "Loss of streaming"); break;        default:            if (ASC == 0x40) { sprintf(str, "Diagnostic failure on component $%02x", ASCQ); break; }            if (ASC == 0x4D) { sprintf(str, "Tagged overlapped commands, queue tag = $%02x", ASCQ); break; }            break;    }        fprintf(stderr, "%s\n", str); }int putString(unsigned char *s,long n,FILE *in){        unsigned int nn;        long last;        int k;        nn=n;        if(nn == n){            if((k=fwrite(s,1,nn,in)) != nn)return 1;        }else{            last=n;            while(last > 0){                nn=32000;                if(nn > last)nn = last;                if((k=fwrite(s,1,nn,in)) != nn)return 1;                s += nn;                last -= nn;            }        }        return 0;}int doDevice(io_service_t service,struct scsiDataStruct *scsiData,             int (*doCommand)(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData)){    IOCFPlugInInterface **plugInInterface = NULL;    SCSITaskDeviceInterface **interface = NULL;    kern_return_t err;    SInt32 score;    HRESULT herr;    int ret;    ret = 0;        if(!doCommand)goto Done3;        err = IOCreatePlugInInterfaceForService ( service,                                                kIOSCSITaskDeviceUserClientTypeID,                                                kIOCFPlugInInterfaceID,                                                &plugInInterface,                                                &score );    if ( err != noErr )    {        fprintf(stderr,"IOCreatePlugInInterfaceForService returned %d\n", err);        goto Done3;            }    herr = ( *plugInInterface )->QueryInterface ( plugInInterface,                                                    CFUUIDGetUUIDBytes (                                                    kIOSCSITaskDeviceInterfaceID ),                                                    ( LPVOID ) &interface );    if ( herr != S_OK )    {        fprintf(stderr,"QueryInterface Error %ld\n",(long)herr);        goto Done2;            }            err = ( *interface )->ObtainExclusiveAccess ( interface );    if ( err != noErr )    {        fprintf(stderr,"ObtainExclusiveAccess Error %ld\n",(long)err);        goto Done2;            }            if((*doCommand)(interface,scsiData))goto Done;               ret = 0;        Done:    (*interface)->ReleaseExclusiveAccess(interface);        (*interface)->Release(interface);Done2:    IODestroyPlugInInterface(plugInInterface);Done3:        return ret;}int readwriteSCSI(SCSICommandDescriptorBlock cdb,SCSITaskDeviceInterface **interface,unsigned char *buff,                  unsigned long bufflength,int direction,struct Sensedata *Sense){    SCSITaskStatus taskStatus;    SCSI_Sense_Data senseDataLocal;    SCSI_Sense_Data *senseData;    SCSITaskInterface ** task = NULL;    IOReturn err = 0;    IOVirtualRange * range = NULL;    UInt64 transferCount = 0;    char *msg;    	if(!cdb || !interface)return 1;	if(bufflength && !buff)return 1;		if(Sense){	    senseData=&Sense->senseData;        memset ( Sense, 0, sizeof (struct Sensedata) );        	}else{	    senseData=&senseDataLocal;        memset (senseData, 0, sizeof (*senseData) );        	}	        msg=NULL;        range = NULL;    task = ( *interface )->CreateSCSITask ( interface );    if ( task != NULL )    {                err = ( *task )->SetCommandDescriptorBlock (task,cdb,kSCSICDBSize_6Byte);        if(err != kIOReturnSuccess){msg="Setting CDB";goto ErrorOut;}                if(bufflength > 0){	        range = ( IOVirtualRange * ) malloc ( sizeof ( IOVirtualRange ) );	        if ( range == NULL ){msg="Mallocing IOVirtualRange";goto ErrorOut;}	        	        	        range->address = ( IOVirtualAddress ) buff;	        	        range->length = bufflength;	        	        if(direction){		        err = ( *task )->SetScatterGatherEntries ( task, range, 1, bufflength,kSCSIDataTransfer_FromInitiatorToTarget);		        if ( err != kIOReturnSuccess ){msg="SG Entries";goto ErrorOut;}	        }else{	        	memset ( buff, 0, sizeof(bufflength));		        err = ( *task )->SetScatterGatherEntries ( task, range, 1, bufflength,kSCSIDataTransfer_FromTargetToInitiator);		        if ( err != kIOReturnSuccess ){msg="SG Entries";goto ErrorOut;}	        }	                }                        err = ( *task )->SetTimeoutDuration ( task, 100000 );        if ( err != kIOReturnSuccess ){msg="Setting Timeout";goto ErrorOut;}                err = ( *task )->ExecuteTaskSync ( task, senseData, &taskStatus,&transferCount );		if(Sense){                	Sense->taskStatus=taskStatus;        	Sense->transferCount=transferCount;        }        if ( err != kIOReturnSuccess ){msg="Executing Task";goto ErrorOut;}                if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){            if(!Sense){                PrintSenseString(senseData);            }else{                msg="CHECK_CONDITION";            }        }ErrorOut:        if(range)free(range);        ( *task )->Release ( task );    }	    if(msg){        if(!Sense)fprintf(stderr,"***** readwriteSCSI Error %s *****\n",msg);        return 1;    }else{    	    return 0;	}}int readwriteSCSI10(SCSICommandDescriptorBlock cdb,SCSITaskDeviceInterface **interface,unsigned char *buff,                  unsigned long bufflength,int direction,struct Sensedata *Sense){    SCSITaskStatus taskStatus;    SCSI_Sense_Data senseDataLocal;    SCSI_Sense_Data *senseData;    SCSITaskInterface ** task = NULL;    IOReturn err = 0;    IOVirtualRange * range = NULL;    UInt64 transferCount = 0;    char *msg;    	if(!cdb || !interface)return 1;	if(bufflength && !buff)return 1;		if(Sense){	    senseData=&Sense->senseData;        memset ( Sense, 0, sizeof (struct Sensedata) );        	}else{	    senseData=&senseDataLocal;        memset ( senseData, 0, sizeof (*senseData) );        	}	        msg=NULL;        range = NULL;    task = ( *interface )->CreateSCSITask ( interface );    if ( task != NULL )    {                err = ( *task )->SetCommandDescriptorBlock ( task, cdb,kSCSICDBSize_10Byte );        if(err != kIOReturnSuccess){msg="Setting CDB";goto ErrorOut;}                if(bufflength > 0){	        range = ( IOVirtualRange * ) malloc ( sizeof ( IOVirtualRange ) );	        if ( range == NULL ){msg="Mallocing IOVirtualRange";goto ErrorOut;}	        	        range->address = ( IOVirtualAddress ) buff;	        	        range->length = bufflength;	        	        if(direction){		        err = ( *task )->SetScatterGatherEntries ( task, range, 1, 255,kSCSIDataTransfer_FromInitiatorToTarget);		        if ( err != kIOReturnSuccess ){msg="SG Entries";goto ErrorOut;}	        }else{	        	memset ( buff, 0, sizeof(bufflength));		        err = ( *task )->SetScatterGatherEntries ( task, range, 1, 255,kSCSIDataTransfer_FromTargetToInitiator);		        if ( err != kIOReturnSuccess ){msg="SG Entries";goto ErrorOut;}	        }	                }                        err = ( *task )->SetTimeoutDuration ( task, 100000 );        if ( err != kIOReturnSuccess ){msg="Setting Timeout";goto ErrorOut;}                err = ( *task )->ExecuteTaskSync ( task, senseData, &taskStatus,&transferCount );		if(Sense){                	Sense->taskStatus=taskStatus;        	Sense->transferCount=transferCount;        }        if ( err != kIOReturnSuccess ){msg="Executing Task";goto ErrorOut;}                /* fprintf(stderr,"taskStatus = %d, transferCount = 0x%08llx ", taskStatus,transferCount); */                        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){            if(!Sense){                PrintSenseString(senseData);            }else{                msg="CHECK_CONDITION";            }        }ErrorOut:        if(range)free(range);        ( *task )->Release ( task );    }	    if(msg){        if(!Sense)fprintf(stderr,"***** readwriteSCSI10 Error %s *****\n",msg);        return 1;    }else{    	    return 0;	}}int SetBlockDevice(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){	    int ret;    ret = 0;                Inquiry(interface,scsiData);           TestUnitReady(interface);        if(ReadBlockLimits(interface,scsiData))goto Done;        ModeWrite(interface,scsiData);		    ret = 0;        Done:    return ret;}void ModeWrite(SCSITaskDeviceInterface **interface,struct scsiDataStruct *scsiData){    unsigned char buff[4096];    SCSICommandDescriptorBlock cdb;        memset ( cdb, 0, sizeof ( cdb ) );        	cdb[0] = 0x1A;    /* Mode Sense(6) */	cdb[2] = 0x3F;	cdb[2] = 0x00;	cdb[4] = 12;	if(readwriteSCSI(cdb,interface,buff,sizeof(buff),ReadFromSCSI,NULL))return;	                 scsiData->Density=buff[4];   scsiData->BufferMode=((buff[2] >> 4) & 7);   scsiData->WriteProtect=(buff[2] & 0x80);   scsiData->BlockSize=65536*buff[9]+256*buff[10]+buff[11];   if(scsiData->PrintLevel)fprintf(stderr,"Density %d Buffer Mode %d Write Protect %d Block Size %d\n",          (int)scsiData->Density,(int)scsiData->BufferMode,(int)scsiData->WriteProtect,(int)scsiData->BlockSize);	              memset ( cdb, 0, sizeof ( cdb ) );        	cdb[0] = 0x15;    /* Mode Select(6) */	/* cdb[1] = 0x10; */	cdb[4] = 12;	    	 	 buff[0]=0;	 	 buff[3]=8;  	      buff[9]=  (scsiData->BlockSizeRead >> 16);     buff[10]= (scsiData->BlockSizeRead >> 8);     buff[11]=  scsiData->BlockSizeRead;    	if(readwriteSCSI(cdb,interface,buff,4096,WriteToSCSI,NULL))return;	          }int readTapeBlocksOLD(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData){    SCSITaskStatus taskStatus;    SCSI_Sense_Data senseData;    SCSICommandDescriptorBlock cdb;    SCSITaskInterface ** task = NULL;    IOReturn err = 0;    IOVirtualRange * range = NULL;    UInt64 transferCount = 0;    UInt32 SizeBuff;        long long sum;    int blks;    int ret;    char *msg;            if(!buff || !buffSize)return 1; // must have        ret = 0;        sum = 0;    msg=NULL;    range=NULL;    SizeBuff = *buffSize;        task = ( *interface )->CreateSCSITask ( interface );    if ( task != NULL )    {         range = ( IOVirtualRange * ) malloc ( sizeof ( IOVirtualRange ) );        if ( range == NULL ){msg="Mallocing IOVirtualRange";goto ErrorOut;}                range->address = ( IOVirtualAddress ) buff;        range->length = SizeBuff;        Start:       memset ( &senseData, 0, sizeof ( senseData ) );                memset ( cdb, 0, sizeof ( cdb ) );        memset ( buff, 0, sizeof ( buff ) );               cdb[0] = 0x08;               if(scsiData->FixedBlock){            cdb[1] = 0x01;           blks=scsiData->BlockCount;        }else{           blks=scsiData->BlockSizeRead;        }                         cdb[2] = (blks >> 16) &  0xFF;        cdb[3] = (blks >> 8) &  0xFF;        cdb[4] = blks & 0xFF;                 err = ( *task )->SetCommandDescriptorBlock ( task, cdb,kSCSICDBSize_6Byte );        if ( err != kIOReturnSuccess ){msg="Setting CDB";goto ErrorOut;}        err = ( *task )->SetScatterGatherEntries ( task, range, 1, SizeBuff,                                                    kSCSIDataTransfer_FromTargetToInitiator );        if ( err != kIOReturnSuccess ){msg="SG Entries";goto ErrorOut;}                err = ( *task )->SetTimeoutDuration ( task, 100000 );        if ( err != kIOReturnSuccess ){msg="Setting Timeout";goto ErrorOut;}                       err = ( *task )->ExecuteTaskSync ( task, &senseData, &taskStatus, &transferCount );        if ( err != kIOReturnSuccess ){msg="Executing Task";goto ErrorOut;}                        sum += transferCount;           /*                  fprintf(stderr,"taskStatus = %d,transferCount = 0x%08llx Total Bytes Read = %lld\n",                    taskStatus, transferCount,sum); 		  */        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                    if(!(senseData.SENSE_KEY & 0x80) && (senseData.SENSE_KEY & 0x0F) != kSENSE_KEY_BLANK_CHECK){            		        if(scsiData->FixedBlock){		            if(transferCount != (scsiData->BlockSizeRead*scsiData->BlockCount)){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead*scsiData->BlockCount);		            }		        }else{		            if(transferCount != scsiData->BlockSizeRead){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead);		            }		        }	        }		}        if(transferCount > 0){            if(putString(buff,(long)transferCount,stdout))goto ErrorOut;        }                    if ( taskStatus == kSCSITaskStatus_GOOD && transferCount > 0)        {            goto Start;        }ErrorOut:        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                        if((senseData.SENSE_KEY & 0x0F) == kSENSE_KEY_NO_SENSE &&               senseData.ADDITIONAL_SENSE_CODE == 0x00 &&               senseData.ADDITIONAL_SENSE_CODE_QUALIFIER == 0x01){                    ret = 2;  // tape mark               		       fprintf(stderr,"readTapeBlocks Tape Mark (sum %lld)\n",sum);		                   }else if((senseData.SENSE_KEY & 0x0F) == kSENSE_KEY_BLANK_CHECK &&               senseData.ADDITIONAL_SENSE_CODE == 0x00 &&               senseData.ADDITIONAL_SENSE_CODE_QUALIFIER == 0x05){                    ret = 3;  // end of media               		       fprintf(stderr,"readTapeBlocks end of media (sum %lld)\n",sum);		                      PrintSenseString(&senseData);            }else{            	PrintSenseString(&senseData);            }         }                    if(msg)fprintf(stderr,"***** readTape Error %s *****\n",msg);                if(range)free ( range );                ( *task )->Release ( task );    }        return ret;}int readTapeBlocksOLD3(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData){    SCSI_Sense_Data senseData;	struct Sensedata Sense;    SCSITaskStatus taskStatus;    SCSICommandDescriptorBlock cdb;    IOReturn err = 0;    UInt64 transferCount = 0;    UInt32 SizeBuff;        long long sum;    int blks;    int ret;    char *msg;            if(!buff || !buffSize)return 1; // must have        ret = 0;        sum = 0;    msg=NULL;    SizeBuff = *buffSize;                    Start:               	memset ( &Sense, 0, sizeof ( Sense ) );       	        memset ( cdb,  0, sizeof ( cdb ) );        memset ( buff, 0, sizeof ( buff) );               cdb[0] = 0x08;               if(scsiData->FixedBlock){            cdb[1] = 0x01;           blks=scsiData->BlockCount;        }else{           blks=scsiData->BlockSizeRead;        }                         cdb[2] = (blks >> 16) &  0xFF;        cdb[3] = (blks >> 8) &  0xFF;        cdb[4] = blks & 0xFF;                          err=readwriteSCSI(cdb,interface,buff,SizeBuff,ReadFromSCSI,&Sense);        transferCount=Sense.transferCount;         taskStatus=Sense.taskStatus;         senseData=Sense.senseData;         if(err){             goto ErrorOut;        }                                    sum += transferCount;           /*                  fprintf(stderr,"taskStatus = %d,transferCount = 0x%08llx Total Bytes Read = %lld\n",                    taskStatus, transferCount,sum); 		  */        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                    if(!(senseData.SENSE_KEY & 0x80) && (senseData.SENSE_KEY & 0x0F) != kSENSE_KEY_BLANK_CHECK){            		        if(scsiData->FixedBlock){		            if(transferCount != (scsiData->BlockSizeRead*scsiData->BlockCount)){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead*scsiData->BlockCount);		            }		        }else{		            if(transferCount != scsiData->BlockSizeRead){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead);		            }		        }	        }		}        if(transferCount > 0){            if(putString(buff,(long)transferCount,stdout))goto ErrorOut;        }                    if ( taskStatus == kSCSITaskStatus_GOOD && transferCount > 0)        {            goto Start;        }ErrorOut:        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                        if(isTapeMark(&senseData)){                    ret = 2;  // tape mark               		       fprintf(stderr,"readTapeBlocks Tape Mark (err %d) (sum %lld) (transferCount %lld)\n",err,sum,transferCount);		       if(scsiData->AskNextTape && ttyin && (sum > 0)){			        err=readwriteSCSI(cdb,interface,buff,SizeBuff,ReadFromSCSI,&Sense);			        if(isEOM(&Sense.senseData)){ 			          {		          		          					        char *c,bufftty[256]; 					        int n;			           			              rewindTape(interface);	Redo:			              fprintf(stderr,"\n   At end of media - Load Next Tape To Read\n");			              fprintf(stderr,"          Type 'continue' to continue \n");			              fprintf(stderr,"             Type 'abort' to abort    \n");			           			              while(1){				              c=fgets(bufftty,255,ttyin);				              if(!c)continue;					          n=strlen(bufftty);					          if(n > 0)bufftty[n-1]=0;				              if(!strcmp(bufftty,"continue")){				                  fprintf(stderr,"Tape Loaded - Continue \n");					              rewindTape(interface);			    				  TestUnitReady(interface);			            		  goto Start;		            		  }else if(!strcmp(bufftty,"abort")){				                  fprintf(stderr,"Tape Load - Abort\n");				                  break;		            		  }else{				                  fprintf(stderr,"Unknown command %s \n",bufftty);				                  goto Redo;		            		  }	            		  }	            	    }			           			        }else if(isTapeMark(&Sense.senseData)){			            skipTape(interface,-1,SkipTapeMarks);			            fprintf(stderr,"Backspace Tape Mark\n");			        }else {			            skipTape(interface,-1,SkipDataBlocks);			            fprintf(stderr,"Backspace Data Block\n");			       }		       }		                   }else if(isEOM(&senseData)){                    ret = 3;  // end of media               		       fprintf(stderr,"readTapeBlocks end of media (sum %lld)\n",sum);		                      PrintSenseString(&senseData);            }else{            	PrintSenseString(&senseData);            }         }                    if(msg)fprintf(stderr,"***** readTape Error %s *****\n",msg);        return ret;}int readTapeBlocksOLD4(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData){    SCSI_Sense_Data senseData;	struct Sensedata Sense;    SCSITaskStatus taskStatus;    SCSICommandDescriptorBlock cdb;    IOReturn err = 0;    UInt64 transferCount = 0;    UInt32 SizeBuff;        long long sum;    int blks;    int ret;    char *msg;            if(!buff || !buffSize)return 1; // must have        ret = 0;        sum = 0;    msg=NULL;    SizeBuff = *buffSize;                    Start:               	memset ( &Sense, 0, sizeof ( Sense ) );       	        memset ( cdb,  0, sizeof ( cdb ) );        memset ( buff, 0, sizeof ( buff) );               cdb[0] = 0x08;               if(scsiData->FixedBlock){            cdb[1] = 0x01;           blks=scsiData->BlockCount;        }else{           blks=scsiData->BlockSizeRead;        }                         cdb[2] = (blks >> 16) &  0xFF;        cdb[3] = (blks >> 8) &  0xFF;        cdb[4] = blks & 0xFF;                          err=readwriteSCSI(cdb,interface,buff,SizeBuff,ReadFromSCSI,&Sense);        transferCount=Sense.transferCount;         taskStatus=Sense.taskStatus;         senseData=Sense.senseData;         if(err){             goto ErrorOut;        }                                    sum += transferCount;           /*                  fprintf(stderr,"taskStatus = %d,transferCount = 0x%08llx Total Bytes Read = %lld\n",                    taskStatus, transferCount,sum); 		  */        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                    if(!(senseData.SENSE_KEY & 0x80) && (senseData.SENSE_KEY & 0x0F) != kSENSE_KEY_BLANK_CHECK){            		        if(scsiData->FixedBlock){		            if(transferCount != (scsiData->BlockSizeRead*scsiData->BlockCount)){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead*scsiData->BlockCount);		            }		        }else{		            if(transferCount != scsiData->BlockSizeRead){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead);		            }		        }	        }		}        if(transferCount > 0){            if(putString(buff,(long)transferCount,stdout))goto ErrorOut;        }                    if ( taskStatus == kSCSITaskStatus_GOOD && transferCount > 0)        {            goto Start;        }ErrorOut:        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                        if(isTapeMark(&senseData)){                    ret = 2;  // tape mark               		       fprintf(stderr,"readTapeBlocks Tape Mark (err %d) (sum %lld) (transferCount %lld)\n",err,sum,transferCount);		       if(scsiData->AskNextTape && ttyin && (sum > 0)){			        err=readwriteSCSI(cdb,interface,buff,SizeBuff,ReadFromSCSI,&Sense);			        if(isEOM(&Sense.senseData)){ 			          {		          		          					        char *c,bufftty[256]; 					        int n;			           			              rewindTape(interface);	Redo:			              fprintf(stderr,"\n   At end of media - Load Next Tape To Read\n");			              fprintf(stderr,"          Type 'continue' to continue \n");			              fprintf(stderr,"             Type 'abort' to abort    \n");			           			              while(1){				              c=fgets(bufftty,255,ttyin);				              if(!c)continue;					          n=strlen(bufftty);					          if(n > 0)bufftty[n-1]=0;				              if(!strcmp(bufftty,"continue")){				                  fprintf(stderr,"Tape Loaded - Continue \n");					              rewindTape(interface);			    				  TestUnitReady(interface);			            		  goto Start;		            		  }else if(!strcmp(bufftty,"abort")){				                  fprintf(stderr,"Tape Load - Abort\n");				                  break;		            		  }else{				                  fprintf(stderr,"Unknown command %s \n",bufftty);				                  goto Redo;		            		  }	            		  }	            	    }			           			        }else if(isTapeMark(&Sense.senseData)){			            skipTape(interface,-1,SkipTapeMarks);			            fprintf(stderr,"Backspace Tape Mark\n");			        }else {			            skipTape(interface,-1,SkipDataBlocks);			            fprintf(stderr,"Backspace Data Block\n");			       }		       }		                   }else if(isEOM(&senseData)){                    ret = 3;  // end of media               		       fprintf(stderr,"readTapeBlocks end of media (sum %lld)\n",sum);		                      PrintSenseString(&senseData);            }else{            	PrintSenseString(&senseData);            }         }                    if(msg)fprintf(stderr,"***** readTape Error %s *****\n",msg);        return ret;}int readTapeBlocksOld8(SCSITaskDeviceInterface **interface,unsigned char *buff,UInt32 *buffSize,struct scsiDataStruct *scsiData){    SCSITaskStatus taskStatus;    SCSI_Sense_Data senseData;    SCSICommandDescriptorBlock cdb;    SCSITaskInterface ** task = NULL;    IOReturn err = 0;    IOVirtualRange * range = NULL;    UInt64 transferCount = 0;    UInt32 SizeBuff;        long long sum;    int blks;    int ret;    char *msg;            if(!buff || !buffSize)return 1; // must have        ret = 0;        sum = 0;    msg=NULL;    range=NULL;    SizeBuff = *buffSize;        task = ( *interface )->CreateSCSITask ( interface );    if ( task != NULL )    {         range = ( IOVirtualRange * ) malloc ( sizeof ( IOVirtualRange ) );        if ( range == NULL ){msg="Mallocing IOVirtualRange";goto ErrorOut;}                range->address = ( IOVirtualAddress ) buff;        range->length = SizeBuff;        Start:       memset ( &senseData, 0, sizeof ( senseData ) );                memset ( cdb, 0, sizeof ( cdb ) );        memset ( buff, 0, sizeof ( buff ) );               cdb[0] = 0x08;               if(scsiData->FixedBlock){            cdb[1] = 0x01;           blks=scsiData->BlockCount;        }else{           blks=scsiData->BlockSizeRead;        }                         cdb[2] = (blks >> 16) &  0xFF;        cdb[3] = (blks >> 8) &  0xFF;        cdb[4] = blks & 0xFF;                 err = ( *task )->SetCommandDescriptorBlock ( task, cdb,kSCSICDBSize_6Byte );        if ( err != kIOReturnSuccess ){msg="Setting CDB";goto ErrorOut;}        err = ( *task )->SetScatterGatherEntries ( task, range, 1, SizeBuff,                                                    kSCSIDataTransfer_FromTargetToInitiator );        if ( err != kIOReturnSuccess ){msg="SG Entries";goto ErrorOut;}                err = ( *task )->SetTimeoutDuration ( task, 100000 );        if ( err != kIOReturnSuccess ){msg="Setting Timeout";goto ErrorOut;}                       err = ( *task )->ExecuteTaskSync ( task, &senseData, &taskStatus, &transferCount );        if ( err != kIOReturnSuccess ){msg="Executing Task";goto ErrorOut;}                        sum += transferCount;           /*                  fprintf(stderr,"taskStatus = %d,transferCount = 0x%08llx Total Bytes Read = %lld\n",                    taskStatus, transferCount,sum); 		  */        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                    if(!(senseData.SENSE_KEY & 0x80) && (senseData.SENSE_KEY & 0x0F) != kSENSE_KEY_BLANK_CHECK){            		        if(scsiData->FixedBlock){		            if(transferCount != (scsiData->BlockSizeRead*scsiData->BlockCount)){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead*scsiData->BlockCount);		            }		        }else{		            if(transferCount != scsiData->BlockSizeRead){                		                fprintf(stderr,"taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",		                    taskStatus, transferCount,(long)scsiData->BlockSizeRead);		            }		        }	        }		}        if(transferCount > 0){            if(putString(buff,(long)transferCount,stdout))goto ErrorOut;        }                    if ( taskStatus == kSCSITaskStatus_GOOD && transferCount > 0)        {            goto Start;        }ErrorOut:        if ( taskStatus == kSCSITaskStatus_CHECK_CONDITION){                        if((senseData.SENSE_KEY & 0x0F) == kSENSE_KEY_NO_SENSE &&               senseData.ADDITIONAL_SENSE_CODE == 0x00 &&               senseData.ADDITIONAL_SENSE_CODE_QUALIFIER == 0x01){                    ret = 2;  // tape mark               		       fprintf(stderr,"readTapeBlocks Tape Mark (err %d) (sum %lld) (transferCount %lld)\n",err,sum,transferCount);		       if(scsiData->AskNextTape && ttyin && (sum > 0)){					struct Sensedata Sense;					/*					cdb[2] = 0;			        cdb[3] = 0;			        cdb[4] = 1;			        */			        err=readwriteSCSI(cdb,interface,buff,SizeBuff,ReadFromSCSI,&Sense);               		PrintSenseString(&Sense.senseData);               		fprintf(stderr,"err %d (taskStatus %d) (transferCount %lld)\n",err,Sense.taskStatus,Sense.transferCount);			        if(isEOM(&Sense.senseData)){ 			          {		          		          					        char *c,bufftty[256]; 					        int n;			           			              rewindTape(interface);	Redo:			              fprintf(stderr,"\n   At end of media - Load Next Tape To Read\n");			              fprintf(stderr,"          Type 'continue' to continue \n");			              fprintf(stderr,"             Type 'abort' to abort    \n");			           			              while(1){				              c=fgets(bufftty,255,ttyin);				              if(!c)continue;					          n=strlen(bufftty);					          if(n > 0)bufftty[n-1]=0;				              if(!strcmp(bufftty,"continue")){				                  fprintf(stderr,"Tape Loaded - Continue \n");					              rewindTape(interface);			    				  TestUnitReady(interface);			            		  goto Start;		            		  }else if(!strcmp(bufftty,"abort")){				                  fprintf(stderr,"Tape Load - Abort\n");				                  break;		            		  }else{				                  fprintf(stderr,"Unknown command %s \n",bufftty);				                  goto Redo;		            		  }	            		  }	            	    }			           			        }else if(isTapeMark(&Sense.senseData)){			            skipTape(interface,-1,SkipTapeMarks);			            fprintf(stderr,"Backspace Tape Mark\n");			        }else {			        	if(scsiData->FixedBlock){				            if(Sense.transferCount != (scsiData->BlockSizeRead*scsiData->BlockCount)){                				                fprintf(stderr,"Read Ahead Fixed Block taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",				                    Sense.taskStatus, Sense.transferCount,(long)scsiData->BlockSizeRead*scsiData->BlockCount);				                if((Sense.transferCount/scsiData->BlockSizeRead) > 0){						            skipTape(interface,-(Sense.transferCount/scsiData->BlockSizeRead),SkipDataBlocks);						            fprintf(stderr,"Backspace Data Block (blks %ld) \n",(long)(Sense.transferCount/scsiData->BlockSizeRead));					            }				            }else{					            skipTape(interface,-scsiData->BlockCount,SkipDataBlocks);					            fprintf(stderr,"Backspace Data Block (blks %d) \n",blks);				            }				        }else{				            if(Sense.transferCount != scsiData->BlockSizeRead){                				                fprintf(stderr,"Read Ahead Variable Block Error: taskStatus = %d Bytes Read = %lld Bytes Expected = %ld\n",				                    Sense.taskStatus, Sense.transferCount,(long)scsiData->BlockSizeRead);				            }else{					            skipTape(interface,-1,SkipDataBlocks);					            fprintf(stderr,"Backspace Data Block (blks %d) \n",blks);				            }				        }			       }		       }		                   }else if((senseData.SENSE_KEY & 0x0F) == kSENSE_KEY_BLANK_CHECK &&               senseData.ADDITIONAL_SENSE_CODE == 0x00 &&               senseData.ADDITIONAL_SENSE_CODE_QUALIFIER == 0x05){                    ret = 3;  // end of media               		       fprintf(stderr,"readTapeBlocks end of media (sum %lld)\n",sum);		                      PrintSenseString(&senseData);            }else{            	PrintSenseString(&senseData);            }         }                    if(msg)fprintf(stderr,"***** readTape Error %s *****\n",msg);                if(range)free ( range );                ( *task )->Release ( task );    }        return ret;}